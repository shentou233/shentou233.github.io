<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"right","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="C++面向对象程序设计类和对象类的定义​	默认情况下，类成员是私有访问的，并且是私有继承的。类的变量和函数成为类的成员。通常一个类由下面的成员构成：  类的数据成员：定义类对象的状态和属性。  一个或多个构造函数：用于初始化类对象。  一个或多个析构函数：用于完成清除工作，如释放动态分配的内存、关闭文件等等。  类的成员函数：定义对象的行为。 类定义的语法规则为 123类关键字(class or">
<meta property="og:type" content="article">
<meta property="og:title" content="伊甸园">
<meta property="og:url" content="http://example.com/2025/02/06/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/index.html">
<meta property="og:site_name" content="伊甸园">
<meta property="og:description" content="C++面向对象程序设计类和对象类的定义​	默认情况下，类成员是私有访问的，并且是私有继承的。类的变量和函数成为类的成员。通常一个类由下面的成员构成：  类的数据成员：定义类对象的状态和属性。  一个或多个构造函数：用于初始化类对象。  一个或多个析构函数：用于完成清除工作，如释放动态分配的内存、关闭文件等等。  类的成员函数：定义对象的行为。 类定义的语法规则为 123类关键字(class or">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-02-06T07:56:10.912Z">
<meta property="article:modified_time" content="2025-02-06T07:54:46.592Z">
<meta property="article:author" content="XuSpring">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2025/02/06/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2025/02/06/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/","path":"2025/02/06/C++面向对象程序设计/","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title> | 伊甸园</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">伊甸园</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">XuSpring's Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.</span> <span class="nav-text">C++面向对象程序设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.1.</span> <span class="nav-text">类和对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">1.1.1.</span> <span class="nav-text">类的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">1.1.2.</span> <span class="nav-text">对象的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B5%8C%E5%A5%97%E7%B1%BB"><span class="nav-number">1.1.3.</span> <span class="nav-text">嵌套类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E4%BB%A5%E5%8F%8A%E7%89%B9%E6%80%A7"><span class="nav-number">1.2.</span> <span class="nav-text">类的成员以及特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.1.</span> <span class="nav-text">构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E5%8F%82%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">无参构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E5%8F%82%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">有参构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">有默认参数构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">拷贝构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA"><span class="nav-number">1.2.1.5.</span> <span class="nav-text">拷贝构造函数调用时机</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.2.</span> <span class="nav-text">析构函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this%E6%8C%87%E9%92%88"><span class="nav-number">1.2.3.</span> <span class="nav-text">this指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.4.</span> <span class="nav-text">空指针访问成员函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%A7%84%E5%88%99"><span class="nav-number">1.2.5.</span> <span class="nav-text">构造函数调用规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.2.6.</span> <span class="nav-text">深拷贝和浅拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.2.6.1.</span> <span class="nav-text">浅拷贝</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.2.6.2.</span> <span class="nav-text">深拷贝</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="nav-number">1.2.7.</span> <span class="nav-text">初始化列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%AD%98%E6%9C%9F"><span class="nav-number">1.2.8.</span> <span class="nav-text">类的作用域和对象的生存期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="nav-number">1.2.9.</span> <span class="nav-text">访问权限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E7%B1%BB%E6%88%90%E5%91%98"><span class="nav-number">1.2.10.</span> <span class="nav-text">类对象作为类成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="nav-number">1.2.11.</span> <span class="nav-text">静态成员</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="nav-number">1.2.11.1.</span> <span class="nav-text">静态成员变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.11.2.</span> <span class="nav-text">静态成员函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.2.12.</span> <span class="nav-text">C++对象模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%88%86%E6%9D%A5%E5%AD%98%E5%82%A8"><span class="nav-number">1.2.12.1.</span> <span class="nav-text">成员变量和成员函数分来存储</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.13.</span> <span class="nav-text">const修饰成员函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.13.1.</span> <span class="nav-text">常函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.2.13.2.</span> <span class="nav-text">常对象</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1-1"><span class="nav-number">1.3.</span> <span class="nav-text">类和对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8B%E5%85%83"><span class="nav-number">1.3.1.</span> <span class="nav-text">友元</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">1.3.2.</span> <span class="nav-text">运算符重载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6-%E9%87%8D%E8%BD%BD"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">加号运算符(+)重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A6%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">左移运算符(&lt;&lt;)重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%92%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6-%E9%87%8D%E8%BD%BD"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">递增运算符(++)重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6-%E9%87%8D%E8%BD%BD"><span class="nav-number">1.3.2.4.</span> <span class="nav-text">赋值运算符(&#x3D;)重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">1.3.2.5.</span> <span class="nav-text">关系运算符重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%EF%BC%89%E9%87%8D%E8%BD%BD"><span class="nav-number">1.3.2.6.</span> <span class="nav-text">函数调用运算符（）重载</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">1.3.3.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">继承方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">对象模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.3.3.4.</span> <span class="nav-text">继承中的构造和析构顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E5%90%8C%E5%90%8D%E7%9A%84%E6%88%90%E5%91%98%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-number">1.3.3.5.</span> <span class="nav-text">继承中同名的成员处理方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF%E8%AF%AD%E6%B3%95"><span class="nav-number">1.3.3.6.</span> <span class="nav-text">多继承语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF"><span class="nav-number">1.3.3.7.</span> <span class="nav-text">菱形继承</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-number">1.3.4.</span> <span class="nav-text">多态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">原理剖析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">1.3.4.3.</span> <span class="nav-text">纯虚函数和抽象类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%92%8C%E7%BA%AF%E8%99%9A%E6%9E%90%E6%9E%84"><span class="nav-number">1.3.4.4.</span> <span class="nav-text">虚析构和纯虚析构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.4.</span> <span class="nav-text">模板</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">1.4.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.4.2.</span> <span class="nav-text">函数模板</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">普通函数与函数模板的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E8%B0%83%E7%94%A8%E8%A7%84%E5%88%99"><span class="nav-number">1.4.2.4.</span> <span class="nav-text">普通函数与函数模板调用规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="nav-number">1.4.2.5.</span> <span class="nav-text">模板的局限性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.4.3.</span> <span class="nav-text">类模板</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95-1"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E6%97%B6%E6%9C%BA"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">成员函数创建时机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%AF%B9%E8%B1%A1%E5%81%9A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="nav-number">1.4.3.4.</span> <span class="nav-text">类模板对象做函数参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="nav-number">1.4.3.5.</span> <span class="nav-text">类模板与继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%B1%BB%E5%A4%96%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.4.3.6.</span> <span class="nav-text">类模板成员函数类外实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%88%86%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99"><span class="nav-number">1.4.3.7.</span> <span class="nav-text">类模板分文件编写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%8F%8B%E5%85%83"><span class="nav-number">1.4.3.8.</span> <span class="nav-text">类模板与友元</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="XuSpring"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">XuSpring</p>
  <div class="site-description" itemprop="description">放码过来</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/06/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XuSpring">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="伊甸园">
      <meta itemprop="description" content="放码过来">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 伊甸园">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-02-06 15:56:10 / 修改时间：15:54:46" itemprop="dateCreated datePublished" datetime="2025-02-06T15:56:10+08:00">2025-02-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="C-面向对象程序设计"><a href="#C-面向对象程序设计" class="headerlink" title="C++面向对象程序设计"></a>C++面向对象程序设计</h1><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><p>​	默认情况下，类成员是私有访问的，并且是私有继承的。类的变量和函数成为类的成员。通常一个类由下面的成员构成：</p>
<ul>
<li><p>类的数据成员：定义类对象的状态和属性。</p>
</li>
<li><p>一个或多个构造函数：用于初始化类对象。</p>
</li>
<li><p>一个或多个析构函数：用于完成清除工作，如释放动态分配的内存、关闭文件等等。</p>
</li>
<li><p>类的成员函数：定义对象的行为。</p>
<p>类定义的语法规则为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类关键字(<span class="keyword">class</span> <span class="keyword">or</span> <span class="keyword">struct</span> <span class="keyword">or</span> <span class="keyword">union</span>) __declspec(可选) 类名(可选) 基类名(可选)&#123;</span><br><span class="line">	成员列表</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>类是可以嵌套的。比如说这里的Tree，Tree的left和right成员都可以定义为Tree类本身的类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tree</span>&#123;</span><br><span class="line">	<span class="type">void</span>*data;</span><br><span class="line">	Tree*left;</span><br><span class="line">	Tree*right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>还可以用typedef隐藏类名。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">int</span> y;</span><br><span class="line">&#125;point;</span><br></pre></td></tr></table></figure>

<h3 id="对象的定义"><a href="#对象的定义" class="headerlink" title="对象的定义"></a>对象的定义</h3><p>对象是在运行时定义了类型的储存区域，除了保存状态信息外，还定义了行为。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>&#123;</span><br><span class="line">	<span class="built_in">Account</span>();<span class="comment">//默认构造器</span></span><br><span class="line">&#125;:Account account;</span><br></pre></td></tr></table></figure>

<p>上面代码首先声明了名为Account的类，然后定义了对象名为account的Account类对象。</p>
<p>还有一种特殊的类——空类</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">noMenclass</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;;<span class="comment">//不包含任何成员的类</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	noMenclass a;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;空类对象的大小为&quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(a)&lt;&lt;endl;<span class="comment">//输出结果显然为1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是它的对象长度并不为o0，长度为1.</p>
<h3 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h3><p>类可以在类中声明，这样的类叫作嵌套类。嵌套类的声明与类的声明相同，只是声明的位置实在其他类的范围之内。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> num=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Dog</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">bark</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Cat</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">jump</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的代码在Animal类中定义了Dog和Cat两个类，注意，这两个类只在Animal类的范围内才有效。而Animal类的对象不包含Dog和Cat类的对象，只是声明了两个类，并没有定义它们的对象。在嵌套类定义的类中定义的变量和类型，在嵌套类中可以使用。比如在Animal::Dog类中可以使用Animal类中定义的num.</p>
<p>嵌套类只在定义的类的范围内有效。要引用一个嵌套类，则必须指定完整的类名。比如我们要引用Animal::Dog里面的bark方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Animal::Dog::<span class="built_in">bark</span>();</span><br></pre></td></tr></table></figure>

<h2 id="类的成员以及特性"><a href="#类的成员以及特性" class="headerlink" title="类的成员以及特性"></a>类的成员以及特性</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>与类名称相同的成员函数成为构造函数，无返回值。如果为类指定了构造函数，则此类型的对象会在创建之前使用构造函数进行初始化。即便没有在构造函数中写代码，构造函数也会执行默认操作，完成必要的初始工作。如果定义类的时候没有写构造函数，系统会生成一个默认的无参构造函数，不做任何工作。</p>
<p>构造函数按参数种类分为：无参构造函数、有参构造函数、有默认参数构造函数。</p>
<h4 id="无参构造函数"><a href="#无参构造函数" class="headerlink" title="无参构造函数"></a>无参构造函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Student</span>() &#123;</span><br><span class="line">		age = <span class="number">18</span>;</span><br><span class="line">		name = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">study</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; name &lt;&lt; <span class="string">&quot;正在学习&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;年龄为 &quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	string name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Student s;</span><br><span class="line">	s.<span class="built_in">showage</span>();</span><br><span class="line">	s.<span class="built_in">study</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="有参构造函数"><a href="#有参构造函数" class="headerlink" title="有参构造函数"></a>有参构造函数</h4><p>顾名思义，就是构造函数中含有参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Student</span>(<span class="type">int</span> a,string n)&#123;</span><br><span class="line">	age=a;</span><br><span class="line">	name=n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">Student <span class="title">s</span><span class="params">(<span class="number">18</span>,<span class="string">&quot;小明&quot;</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对上面的代码，我们做了一点小改动，显然当我们创建类的时候，需要传入相应的参数，与上面的无参构造函数有区别。</p>
<h4 id="有默认参数构造函数"><a href="#有默认参数构造函数" class="headerlink" title="有默认参数构造函数"></a>有默认参数构造函数</h4><p>在对象的实例化时，若传入了参数，则传入的参数优先，若没有传入参数，则使用默认参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Student</span>(<span class="type">int</span> a,string n=<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">Student::<span class="built_in">Student</span>(<span class="type">int</span> a,<span class="type">int</span> n)&#123;</span><br><span class="line">	age=a;</span><br><span class="line">	name=n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们设置了name（姓名）的默认参数为”小明”，如果我们在创建类的时候，传入一个新的参数，最后我们得到的就是该参数，否则为默认参数。但是age（年龄）我们并没有设置默认参数，因此无论name给不给定参数，我们都需要给age传入相应的参数。</p>
<p>注意：</p>
<ul>
<li><p>在一个类中定义了一个带默认参数的构造函数后，不能再定义有冲突的重载构造函数。	</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Student</span>(<span class="type">int</span> a,string n=<span class="string">&quot;小明&quot;</span>);</span><br><span class="line"><span class="built_in">Student</span>(<span class="type">int</span> a=<span class="number">18</span>,string n=<span class="string">&quot;小明&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>​	像上面这种重定义的带默认参数的构造器就是错误的</p>
<ul>
<li><p>参数缺省值只能出现在函数的声明中，而不能出现在定义体中。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Student</span>(<span class="type">int</span> a,string n=<span class="string">&quot;小明&quot;</span>)&#123;</span><br><span class="line">	age=a;</span><br><span class="line">	name=n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码显然为定义体，但是缺省值却出现在传参列表中，明显是错误的。</p>
</li>
<li><p>如果函数有多个参数，参数只能从前往后挨个儿缺省。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Student</span>(<span class="type">int</span> a=<span class="number">18</span>,string n);<span class="comment">//×</span></span><br><span class="line"><span class="built_in">Student</span>(<span class="type">int</span> a,string n=<span class="string">&quot;小明&quot;</span>);<span class="comment">//√</span></span><br></pre></td></tr></table></figure>

<p>多个参数只能先写缺省值，然后再写默认值。</p>
</li>
</ul>
<p>构造函数按类型分为：普通构造函数，拷贝（复制）构造函数。</p>
<h4 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h4><p>上面所说的均为默认构造函数，当对象与对象之间进行复制时，需要用到拷贝构造函数。如果没有定义拷贝构造函数，编译器会自动生成一个拷贝构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Student <span class="title">s</span><span class="params">(<span class="number">18</span>,<span class="string">&quot;小明&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">Student <span class="title">s1</span><span class="params">(s)</span></span>;</span><br></pre></td></tr></table></figure>

<p>还是用到上面的例子，这里的s1就是经过s拷贝而来的。</p>
<p>下面，将介绍几种拷贝构造函数的调用方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> num;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造器&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> num) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;num = num;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造器&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp;p) &#123;</span><br><span class="line">		num = p.num;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person()析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>括号法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">b</span><span class="params">(a)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>显式法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = <span class="built_in">Person</span>(<span class="number">10</span>);</span><br><span class="line">Person p2 = <span class="built_in">Person</span>(p1);</span><br></pre></td></tr></table></figure>

<p>这里的Person(10)叫做匿名对象，当前行执行结束后，系统会立即回收掉匿名对象。</p>
<p>此外，不要利用拷贝构造函数初始化匿名对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Person</span>(p2);<span class="comment">//x</span></span><br></pre></td></tr></table></figure>

<p>针对上面的代码，这种方案是不可行的。编译器会认为<code>Person(p2);</code>等价于<code>Person p2;</code>导致重定义。</p>
</li>
<li><p>隐式法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p3 = <span class="number">10</span>;<span class="comment">//相当于Person p3 = Person(10);</span></span><br><span class="line">Person p4 = p3;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="拷贝构造函数调用时机"><a href="#拷贝构造函数调用时机" class="headerlink" title="拷贝构造函数调用时机"></a>拷贝构造函数调用时机</h4><ul>
<li><p>使用一个已经创建完毕的对象来初始化一个新对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>值传递的方式给函数参数传值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们在主函数调用它时，会自动拷贝一份到test2函数当中</p>
</li>
<li><p>值方式返回局部对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Person p1;</span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span>*)&amp;p1 &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> p1;<span class="comment">//返回值优化，避免了不必要的拷贝构造 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person p = <span class="built_in">work</span>();</span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span>*)&amp;p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在以前的版本中，这种方法是能调用拷贝构造的，但是在后面的版本中，编译器进行了返回值优化，优化掉不必要的拷贝复制函数的调用。因此，当我们调用test3函数时，只会调用一个默认构造函数。且p1和p的地址也是一样的。</p>
</li>
</ul>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>析构函数是构造函数的逆操作，当对象销毁或者释放时，系统会自动调用析构函数。指定析构函数的方法是在类中增加一个函数，然后再类名前加一个“~”号。当不再需要对象时，析构函数会清除对象所占用的资源。如果程序语言没有提供析构函数，编译器将隐式地声明一个默认析构函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">point</span>(<span class="type">char</span>* c);</span><br><span class="line">	~<span class="built_in">point</span>();<span class="comment">//析构函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">double</span> x;</span><br><span class="line">	<span class="type">double</span> y;</span><br><span class="line">	<span class="type">char</span>* c;</span><br><span class="line">&#125;;</span><br><span class="line">point::<span class="built_in">point</span>(<span class="type">char</span>* str) &#123;<span class="comment">//实现将传入的字符拼接操作</span></span><br><span class="line">	c = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str)];<span class="comment">//开辟一段新的内存</span></span><br><span class="line">	<span class="keyword">if</span> (c)<span class="built_in">strcpy</span>(c, str);</span><br><span class="line">&#125;</span><br><span class="line">point::~<span class="built_in">point</span>() &#123;</span><br><span class="line">	<span class="keyword">delete</span>[] c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">point::print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(c); i++) &#123;</span><br><span class="line">		cout &lt;&lt; c[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">char</span> s1[] = <span class="string">&quot;aaaa&quot;</span>;</span><br><span class="line">	<span class="function">point <span class="title">p</span><span class="params">(s1)</span></span>;</span><br><span class="line">	p.<span class="built_in">print</span>();</span><br><span class="line">	p.~<span class="built_in">point</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里析构函数的作用就体现出来了，它将构造函数创建的字符数组的内释放。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Animal</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;animal构造函数 &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Animal</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;animal析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person p;</span><br><span class="line">	Animal a;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//output   Person构造函数</span></span><br><span class="line">	<span class="comment">//         animal构造函数</span></span><br><span class="line">	<span class="comment">//         animal析构函数</span></span><br><span class="line">	<span class="comment">//         Person析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意构造和析构的先后顺序，上面这段代码，我们依次创建了两个对象，但是输出结果并不与我们想象的那样先创建的先销毁，后创建的后销毁。而是先构造的后析构，后构造的先析构。</p>
<p>下面补充一下delete和delete[]的区别：我们都知道，delete释放new分配的单个对象指针指向的内存，delete[]释放new分配的对象数组指针指向的内存。</p>
<p>对于简单类型，如 int *a&#x3D;new int[10] ，这种无论采用delete还是delete[]都是可以的，因为分配简单类型内存时，内存大小已经确定，系统可以记忆并且进行管理，在析构时，系统不会调用析构函数。它直接通过指针获取一段分配的空间。</p>
<p>但是，针对class，这两种方式就体现出差异了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;构造函数被调用~&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">A</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数被调用~&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	A* a = <span class="keyword">new</span> A[<span class="number">3</span>];</span><br><span class="line">	<span class="comment">//delete a;</span></span><br><span class="line">	<span class="keyword">delete</span>[]a;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们使用delete[]的时候，输出结果为三个“构造函数”，三个“析构函数”，说明资源释放完全了，但是我们使用delete时，只出现了一句“析构函数”，且引发了错误，说明资源释放的不充分，只是释放了a[0]的内存，其他的内存并没有释放，从而导致内存泄漏。</p>
<h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>this指针只能在成员函数中使用，它指向被调用的成员函数所属的对象。当一个对象的成员函数被调用时，编译器会隐式地传递该对象的地址作为 this 指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">int</span> num) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;num = num;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="keyword">this</span>-&gt;num;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过使用this指针，我们可以在成员函数中访问当前对象的成员变量，即便他们的函数参数与局部变量同名，这样可以避免命名冲突。</p>
<p>来看下面一段代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Person&amp; <span class="title">PersonAdd</span><span class="params">(Person &amp;p)</span> </span>&#123;<span class="comment">//返回值为引用</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	p1.<span class="built_in">PersonAdd</span>(p).<span class="built_in">PersonAdd</span>(p).<span class="built_in">PersonAdd</span>(p);<span class="comment">//链式写法</span></span><br><span class="line">	cout &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们写了一个<code>PersonAdd</code>函数，但注意到它的返回值为<code>Person&amp;</code>，那么通过引用返回究竟有什么用处呢？这个函数的主要目的就是，传入一个Person类，将它的age属性加到我们自己的Person类的age属性上，然后再返回我们的Person类。</p>
<p><code>return *this</code>返回的是当前对象的克隆或者本身（如果返回类型为A，则是克隆，会调用拷贝构造函数，返回的对象是拷贝出来的副本；如果返回类型为A&amp;，则是本身）在这里，显然是返回的本身。还有一个与之相对的<code>return this</code>，他会返回当前对象的地址，因此为什么要加上一个星号，作用就在于解引用。</p>
<p>在主函数中，我们反复调用了三次这个函数，因为返回值为类，我们能用链式写法，即<code>p1.PersonAdd(p).PersonAdd(p).PersonAdd(p);</code>，输出结果为40.</p>
<p>现在我们将<code>PersonAdd</code>函数的返回值改为Person，输出结果将发生变化为20，因为返回值是值类型，每一次调用函数将会创建一个新对象，并返回新对象。所以，无论调用几次<code>PersonAdd</code>函数，实际上只有一次效果。</p>
<h3 id="空指针访问成员函数"><a href="#空指针访问成员函数" class="headerlink" title="空指针访问成员函数"></a>空指针访问成员函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showname</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//if (this == NULL)return;</span></span><br><span class="line">        <span class="comment">//特判</span></span><br><span class="line">		cout &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person* p = <span class="literal">NULL</span>;</span><br><span class="line">	p-&gt;<span class="built_in">showage</span>();</span><br><span class="line">	p-&gt;<span class="built_in">showname</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行时出错，原因在于<code>showage</code>，空指针指向的属性无法表示，因此直接报错。最佳办法是增加一个特判，这样也能提高代码的健壮性。</p>
<h3 id="构造函数调用规则"><a href="#构造函数调用规则" class="headerlink" title="构造函数调用规则"></a>构造函数调用规则</h3><p>默认情况下，c++编译器至少给一个类添加3个函数</p>
<ul>
<li>默认构造函数</li>
<li>默认析构函数</li>
<li>默认拷贝构造函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们并没有写拷贝构造函数，但是输出结果为两句“析构函数调用”，说明编译器自动帮我们创建了一个拷贝构造函数。另外两个就不举例了，比较简单。</p>
<p>此外，如果你写了拷贝构造函数，那么编译器就不提供默认构造函数以及有参构造函数。</p>
<h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>利用编译器提供的拷贝构造函数，会做浅拷贝操作。它仅复制对象的基本类型成员和指针成员的值，而不复制指针所指向的内存。这可能导致两个对象共享相同的资源，从而引发潜在的问题，如内存泄漏、意外修改共享资源等。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">int</span>* num;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp;p) &#123;</span><br><span class="line">		age = p.age;</span><br><span class="line">		num = p.num;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age, <span class="type">int</span> num) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">		<span class="keyword">this</span>-&gt;num = <span class="keyword">new</span> <span class="built_in">int</span>(num);<span class="comment">//创建在堆区</span></span><br><span class="line">		<span class="comment">//堆区开辟的空间需要手动释放，所以在析构函数里需要释放</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		<span class="keyword">if</span> (num != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">delete</span> num;</span><br><span class="line">			num = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码我们写了两个属性，age和num，分别用int和int指针型来表示。指针型的变量需要创建在堆区，因此在释放时候需要我们手动进行释放，所以在析构函数中需要增加一条delete操作。但是运行的时候就会报错</p>
<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>重新在堆区申请一空间，防止释放内存操作的冲突，以解决浅拷贝带来的问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp;p) &#123;</span><br><span class="line">	age = p.age;</span><br><span class="line">	num = <span class="keyword">new</span> <span class="built_in">int</span>(*p.num);<span class="comment">//深拷贝</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;拷贝构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：如果属性有在堆区开辟的，那么一定要自己提供拷贝构造函数，防止浅拷贝带来的问题。</p>
<h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a_num,<span class="type">int</span> b_num,<span class="type">int</span> c_num) :<span class="built_in">a</span>(a_num), <span class="built_in">b</span>(b_num), <span class="built_in">c</span>(c_num) &#123;</span><br><span class="line">		<span class="comment">//初始化列表</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; p.a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p.b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p.c &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化列表提供了一种相对于传统构造函数更为简单的方法，只需写一行即能完成对属性的赋值。一定要注意冒号的位置！！！</p>
<h3 id="类的作用域和对象的生存期"><a href="#类的作用域和对象的生存期" class="headerlink" title="类的作用域和对象的生存期"></a>类的作用域和对象的生存期</h3><p>类的作用域是指定义的有效范围，类的数据成员</p>
<p>按生命期的不同，对象可分为如下四种：</p>
<ul>
<li><p>局部对象</p>
<p>局部对象在运行函数时被创建，调用构造函数；当函数运行结束时被释放，调用析构函数。</p>
</li>
<li><p>静态对象</p>
</li>
<li><p>全局对象</p>
<p>全局对象在程序开始运行时，main运行前创建对象，并调用构造函数；在程序运行结束时被释放，调用析构函数。</p>
</li>
<li><p>自由储存对象</p>
<p>用new分配的自由储存对象在new运算时创建对象，并调用构造函数；在delete运算时被释放，调用析构函数。自由储存对象一经new运算创建，就会始终保持知道delete运算时，即使程序运行结束它也不会自动释放。</p>
</li>
</ul>
<h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><ul>
<li>公共权限（public）：类内和类外都能访问</li>
<li>保护权限（protected）：类内能访问，类外不能访问</li>
<li>私有权限（private）：类内能访问，类外不能访问</li>
</ul>
<p>值得注意的是，保护权限和私有权限的区别是，子类能访问父类的保护内容却不能访问它的私有内容。</p>
<p><code>struct</code>和<code>class</code>的区别：默认访问权限不同。<code>struct</code>默认访问权限为公共，<code>class</code>默认访问权限为私有。</p>
<h3 id="类对象作为类成员"><a href="#类对象作为类成员" class="headerlink" title="类对象作为类成员"></a>类对象作为类成员</h3><p>c++类中的成员可以是另一个类的对象，就叫做对象成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string pname;</span><br><span class="line">	<span class="built_in">Phone</span>(string name) &#123;</span><br><span class="line">		pname = name;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Phone有参构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Phone</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Phone析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string name;</span><br><span class="line">	Phone phone;</span><br><span class="line">	<span class="built_in">Person</span>(string name, string pname) :<span class="built_in">name</span>(name), <span class="built_in">phone</span>(pname) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person有参构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;<span class="comment">//初始化列表</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;jack&quot;</span>, <span class="string">&quot;iphone&quot;</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; p.name &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; p.phone.pname &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们创建了两个类：Person和Phone.在Person类中，我们增加了一个Phone属性，这就是对象成员。</p>
<p>注意：当其他类对象作为本类成员，构造时先构造类对象，再构造自身；析构时先析构自身，再析构类对象。因此上面的输出顺序为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Phone有参构造函数</span><br><span class="line">Person有参构造函数</span><br><span class="line">Person析构函数</span><br><span class="line">Phone析构函数</span><br></pre></td></tr></table></figure>

<h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><h4 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h4><ul>
<li><p>类内声明，类外初始化操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> n;<span class="comment">//类内声明</span></span><br><span class="line">    <span class="comment">//static int n=100; (X)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::n = <span class="number">100</span>;<span class="comment">//类外初始化</span></span><br><span class="line"><span class="comment">//static int n=100; (X)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person p;</span><br><span class="line">	cout &lt;&lt; p.n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码很好地阐述了类内声明，类外初始化的操作。注释中所展示的都是常见的错误写法。</p>
</li>
<li><p>所有对象都共享一份数据</p>
<p>有两种访问方式：通过对象进行访问和通过类名进行访问。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p;</span><br><span class="line">cout &lt;&lt; p.n &lt;&lt; endl;<span class="comment">//对象访问</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; Person::n &lt;&lt; endl;<span class="comment">//类名访问</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编译阶段分配内存</p>
</li>
<li><p>静态成员变量也是有访问权限的</p>
</li>
</ul>
<h4 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;fun&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person p;</span><br><span class="line">	p.<span class="built_in">fun</span>();</span><br><span class="line"></span><br><span class="line">	Person::<span class="built_in">fun</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原理跟静态成员变量一样。</p>
<p>注意，静态成员函数只能访问静态成员变量。</p>
<h3 id="C-对象模型"><a href="#C-对象模型" class="headerlink" title="C++对象模型"></a>C++对象模型</h3><h4 id="成员变量和成员函数分来存储"><a href="#成员变量和成员函数分来存储" class="headerlink" title="成员变量和成员函数分来存储"></a>成员变量和成员函数分来存储</h4><p>空对象占用内存为1. C++编译器会给每个空对象也分配一个字节的空间，是为了区分空对象占内存的位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person p;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;对象占用内存为&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当对象中有一个成员变量时，它占用的内存为4，说明非静态成员变量属于类的对象上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person p;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;对象占用内存为&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们多加一个static，那么大小又变回1了，说明静态成员变量不属于类的对象。同理，当一个类同时又静态成员变量和非静态成员变量时，它们的效果不是叠加的，即大小还是4.还有，非静态成员函数和静态成员函数都是不属于类的对象上的。</p>
<h3 id="const修饰成员函数"><a href="#const修饰成员函数" class="headerlink" title="const修饰成员函数"></a><code>const</code>修饰成员函数</h3><h4 id="常函数"><a href="#常函数" class="headerlink" title="常函数"></a>常函数</h4><ul>
<li><p>成员函数后加<code>const</code>称为常函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>常函数内不可修改成员属性</p>
<p>this指针的本质是指针常量，指针的指向是不能修改的，但是指针的值能修改。但当我们在函数后加上一个<code>const</code>，使其变为常函数，本质上修饰的是this指针，让指针指向的值不可修改。</p>
</li>
<li><p>成员属性声明时加关键字mutable后，在常函数中依然可以修改</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mutable</span> <span class="type">int</span> age;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="常对象"><a href="#常对象" class="headerlink" title="常对象"></a>常对象</h4><ul>
<li><p>声明对象前加<code>const</code>称为常对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Person p;</span><br></pre></td></tr></table></figure>
</li>
<li><p>常对象只能用常函数</p>
</li>
<li><p>常对象不允许修改其属性的值</p>
</li>
</ul>
<h2 id="类和对象-1"><a href="#类和对象-1" class="headerlink" title="类和对象"></a>类和对象</h2><h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>让一个函数或者类访问另一个类中私有成员</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul>
<li><p>全局函数做友元</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">show</span><span class="params">(Building build)</span></span>;<span class="comment">//友元声明</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Building</span>() &#123;</span><br><span class="line">		a = <span class="string">&quot;aa&quot;</span>;</span><br><span class="line">		b = <span class="string">&quot;bb&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string a;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(Building build)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; build.a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; build.b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Building build;</span><br><span class="line">	<span class="built_in">show</span>(build);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在类的最开始加上友元（friend）的声明，然后我们就能在函数中放心大胆地访问私有属性了。</p>
</li>
<li><p>类做友元</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span> &#123;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Person</span>;<span class="comment">//友元类声明</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Building</span>() &#123;</span><br><span class="line">		a = <span class="string">&quot;aa&quot;</span>;</span><br><span class="line">		b = <span class="string">&quot;bb&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string a;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Building *build;</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		build = <span class="keyword">new</span> Building;<span class="comment">//构造函数在堆区申请内存</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; build-&gt;a &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; build-&gt;b &lt;&lt; endl;<span class="comment">//访问私有属性</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person p;</span><br><span class="line">	p.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test2</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟上面如出一辙，都是在类的最开始加上友元声明，进而访问私有属性。</p>
</li>
<li><p>成员函数做友元</p>
<p>这一块内容有点小坑，咱们来设置一个情景</p>
<p>定义两个类：客人类（guest）和建筑类（building），实现对客人类不同的访问权限。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">guest</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string name;</span><br><span class="line">    building* build;</span><br><span class="line">	<span class="built_in">guest</span>(string name) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">		build = <span class="keyword">new</span> building;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(building *build)</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; build-&gt;living_room;</span><br><span class="line">		cout &lt;&lt; build-&gt;bedroom;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">building</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">guest::visit</span><span class="params">(building build)</span></span>;<span class="comment">//友元函数基本语法，注意void的位置</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string bedroom;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string living_room;</span><br><span class="line">	<span class="built_in">building</span>() &#123;</span><br><span class="line">		bedroom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">		living_room = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这段代码看着没什么问题，但是访问私有属性的时候却出现了错误。因为guest里用到了building类的初始化，即便是在开头声明了building，但是编译器仍然找不到building的构造器，因此我们需要将guest里面涉及到building类的函数全部写在最后。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">guest</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	building *build;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="built_in">guest</span>(string name);<span class="comment">//不要忘了声明</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;<span class="comment">//不要忘了声明</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">building</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">guest::visit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string bedroom;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string living_room;</span><br><span class="line">	<span class="built_in">building</span>() &#123;</span><br><span class="line">		bedroom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">		living_room = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//==============================</span></span><br><span class="line"><span class="comment">//涉及到building的写在文末</span></span><br><span class="line">guest::<span class="built_in">guest</span>(string name) &#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">	build = <span class="keyword">new</span> building;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">guest::visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; name &lt;&lt; <span class="string">&quot;访问了&quot;</span> &lt;&lt; build-&gt;living_room &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; name &lt;&lt; <span class="string">&quot;访问了&quot;</span> &lt;&lt; build-&gt;bedroom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//==============================</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">guest <span class="title">g</span><span class="params">(<span class="string">&quot;jack&quot;</span>)</span></span>;</span><br><span class="line">	g.<span class="built_in">visit</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时就能正常访问私有属性啦。</p>
<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>对已有运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型。</p>
<h4 id="加号运算符-重载"><a href="#加号运算符-重载" class="headerlink" title="加号运算符(+)重载"></a>加号运算符(+)重载</h4><ul>
<li><p>成员函数重载</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">	&#125;</span><br><span class="line">	Person <span class="keyword">operator</span>+(Person &amp;p) &#123;</span><br><span class="line">		<span class="comment">//成员函数重载</span></span><br><span class="line">		<span class="function">Person <span class="title">temp</span><span class="params">(<span class="keyword">this</span>-&gt;a + p.a,<span class="keyword">this</span>-&gt;b + p.b)</span></span>;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里用到的operator+并不是我们随便起的，而是编译器严格定义的，想要重载运算符必须得用这种命名方式。然后，将两个类各个属性的加和赋值给一个新的类，并返回这个类。这样，就实现了两个类相加。</p>
</li>
<li><p>全局函数重载</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person <span class="keyword">operator</span>+(Person &amp;p1,Person &amp;p2) &#123;</span><br><span class="line">	<span class="comment">//全局函数重载</span></span><br><span class="line">	<span class="function">Person <span class="title">temp</span><span class="params">(p1.a + p2.a, p1.b + p2.b)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理上文，唯一与上面不一样的是，传入的参数不一样。成员函数重载是因为本身就是一个类，可以调用自身的属性。而这个是定义在类外的，因此需要传入两个类参数。</p>
</li>
</ul>
<p>值得注意的是，无论是成员函数重载还是全局函数重载，其本质上均是<code>Person p3 = p1.operator+(p2)</code>或<code>Person p3 = operator+(p1, p2)</code>这两种形式，只不过编译器直接将他们变成<code>Person p3 = p1 + p2</code>以简化操作。</p>
<p>当然，两个数据类型，可以不仅仅局限为两个类，一个类一个整形等等都可以。</p>
<p>下面就是类与整形相加的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person <span class="keyword">operator</span>+(Person &amp;p, <span class="type">int</span> num) &#123;</span><br><span class="line">	<span class="function">Person <span class="title">temp</span><span class="params">(p.a + num, p.b + num)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="左移运算符"><a href="#左移运算符" class="headerlink" title="左移运算符(&lt;&lt;)重载"></a>左移运算符(&lt;&lt;)重载</h4><p>我们在输出一个数据的时候，通常会用到<code>cout&lt;&lt;</code>……，但是想要输出一个类，那么这个方法就行不通了。于是乎可以用运算符重载。</p>
<ul>
<li><p>成员函数重载</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="keyword">operator</span>&lt;&lt;(ostream &amp;cout) &#123;</span><br><span class="line">	cout &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依照上面的加法运算符重载，我们可以照葫芦画瓢。这里传入的参数为<code>cout</code>，而他的类型是<code>ostream</code>（输出流），然后我们就可以在函数体内自定义我们想要输出的格式了。</p>
<p>但是当我们依照惯例使用<code>cout&lt;&lt;P</code>的时候，报错了。而<code>p&lt;&lt;cout</code>却是对的。因为在成员函数中，这种重载相当于<code>p.operator&lt;&lt;(cout);</code>，显然，这种编写格式不符合我们编写代码的惯例，因此一般不会利用成员函数重载&lt;&lt;</p>
</li>
<li><p>全局函数重载</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;cout,Person &amp;p) &#123;</span><br><span class="line">	cout &lt;&lt; p.a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p.b &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> cout;<span class="comment">//链式编程思想</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这里不要慌，出现了很多没见过的东西。</p>
<p>首先，这个函数的类型为<code>ostream&amp;</code>，为什么当函数运行结束时还要返回一个<code>cout</code>呢？我们之前在类对象中说过链式编程的思想，就是一个类反复调用自身的函数，最终得出结果的案例。那么在这里我们就能明显感受到链式编程思想带来的好处。如果这个函数仍然为初始的<code>void</code>，那么我们输出一次就不能继续输出了，<code>cout&lt;&lt;p&lt;&lt;endl</code>这种方式是错误的。而当我们用链式编程思想，就能迎刃而解了。</p>
</li>
</ul>
<h4 id="递增运算符-重载"><a href="#递增运算符-重载" class="headerlink" title="递增运算符(++)重载"></a>递增运算符(++)重载</h4><p>递增运算符有两种，一个是前置递增，还有一个是后置递增。</p>
<ul>
<li><p>前置递增</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person&amp; <span class="keyword">operator</span>++() &#123;<span class="comment">//返回引用是为了一直对一个数据进行操作</span></span><br><span class="line">	num++;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里唯一需要注意的就是重载函数的返回值，首先递增必然是返回同一个都对象，其次返回引用。</p>
</li>
<li><p>后置递增</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Person <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">	<span class="comment">//int代表占位参数，可以用于区分前置和后置递增</span></span><br><span class="line">	Person temp = *<span class="keyword">this</span>;</span><br><span class="line">	num++;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">	<span class="comment">//不能返回引用，因为这个temp是局部对象，执行完就销毁了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后置递增用到了一个临时创建的类。</p>
</li>
</ul>
<h4 id="赋值运算符-重载"><a href="#赋值运算符-重载" class="headerlink" title="赋值运算符(&#x3D;)重载"></a>赋值运算符(&#x3D;)重载</h4><p>前文我们说到，编译器至少给一个类提供3个函数：默认无参构造函数，默认拷贝构造函数和默认析构函数。现在我们将再增加一个：赋值运算符重载。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">p1=p;</span><br></pre></td></tr></table></figure>

<p>这种语法是没有问题的。</p>
<p>但是，一旦我们在类中存在建立在堆中的属性，那么这个方法显然就不适用了。还是回到上文所讲的：我们在析构函数中增加一个<strong>主动销毁</strong>的操作，即：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">Person</span>() &#123;</span><br><span class="line">	<span class="keyword">if</span> (age != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">delete</span> age;</span><br><span class="line">		age = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果为浅拷贝，那么这段代码将会反复执行，同一块内存也会被反复析构，从而造成内存泄漏。但是编译器给我们提供的赋值运算符重载是浅拷贝，因此我们要进行改进。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Person&amp; <span class="keyword">operator</span>=(Person &amp;p) &#123;<span class="comment">//引用返回，以实现连续赋值操作，与左移运算符重载操作一样</span></span><br><span class="line">	<span class="keyword">if</span> (age != <span class="literal">NULL</span>) &#123;<span class="comment">//这里需要判断一下该属性在堆中的内存是不是干净的，如果有，也要即使清理掉，防止后患</span></span><br><span class="line">		<span class="keyword">delete</span> age;</span><br><span class="line">		age = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	age = <span class="keyword">new</span> <span class="built_in">int</span>(*p.age);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与之前的深拷贝类似，我们在进行赋值的时候，不单单要进行值的赋值，还要新建一块内存。</p>
<h4 id="关系运算符重载"><a href="#关系运算符重载" class="headerlink" title="关系运算符重载"></a>关系运算符重载</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="keyword">operator</span>==(Person p) &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;age == p.age)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于这块内容较为简单，这里就给出一个大致参考。包括不等，大于和小于号都可以用这种写法重载。</p>
<h4 id="函数调用运算符（）重载"><a href="#函数调用运算符（）重载" class="headerlink" title="函数调用运算符（）重载"></a>函数调用运算符（）重载</h4><p>这个括号就是函数后面跟着的小括号，其实它也能重载。</p>
<p>由于重载后使用的方式非常像函数的调用，因此成为仿函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Add</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> n1,<span class="type">int</span> n2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> n1 + n2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Add add;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">add</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里引入一个匿名函数对象，上面的函数体内可以这么改：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;<span class="built_in">Add</span>()(<span class="number">10</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>这样无需创建一个新对象就能调用函数了。</p>
</li>
</ul>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>基本语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 子类 : 继承方式 父类&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，子类也称为派生类，父类也成为基类</p>
<p>下面来看具体案例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;m1&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;m2&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>:<span class="keyword">public</span> Father&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">mm1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mm1&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">mm2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mm2&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Son son;</span><br><span class="line">	son.<span class="built_in">m1</span>();</span><br><span class="line">	son.<span class="built_in">m2</span>();</span><br><span class="line">	son.<span class="built_in">mm1</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里父类的方法在子类中都能用到，减少重复的代码，这就是继承的好处。</p>
<h4 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h4><ul>
<li><p>公共继承</p>
<p>父类的公共属性和保护属性到了子类仍然不变</p>
</li>
<li><p>保护继承</p>
<p>父类中的公共属性和保护属性到了子类均变为保护属性</p>
</li>
<li><p>私有继承</p>
<p>父类中的公共属性和保护属性到了子类均变为私有属性</p>
</li>
</ul>
<p>父类中的私有属性在子类中均不可访问，无论用哪种继承方式。</p>
<h4 id="对象模型"><a href="#对象模型" class="headerlink" title="对象模型"></a>对象模型</h4><p>那么子类究竟占多大的空间呢？下面我们来讨论一下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> aa;</span><br><span class="line">	<span class="type">int</span> bb;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> cc;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> dd;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Son son;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(son) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面的结果可以看到，结果是16，显而易见，子类中包含父类以及自身的属性。因此我们能得出结论：</p>
<p>父类中所有非静态成员属性都会被子类继承下去，父类中私有成员属性是被编译器给隐藏了，因此访问不到，但是却被继承下去了。</p>
<h4 id="继承中的构造和析构顺序"><a href="#继承中的构造和析构顺序" class="headerlink" title="继承中的构造和析构顺序"></a>继承中的构造和析构顺序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Base</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Son</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>先构造父类再构造子类，而析构的顺序是相反的。</p>
<h4 id="继承中同名的成员处理方式"><a href="#继承中同名的成员处理方式" class="headerlink" title="继承中同名的成员处理方式"></a>继承中同名的成员处理方式</h4><p>当子类和父类拥有同名的属性或者函数时，我们是不能直接访问父类的成员的，直接访问也只能是子类的。那如果我们想访问父类的属性或函数该怎么办呢？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> a=<span class="number">20</span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base.m&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> a=<span class="number">100</span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son.m&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Son s;</span><br><span class="line">	cout &lt;&lt; s.Base::a &lt;&lt; endl;</span><br><span class="line">	s.Base::<span class="built_in">m</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候只需加一个作用域即可，一定要注意是两个冒号！</p>
<p>此外，这种形式的本质是：如果子类中出现和父类同名的成员函数，子类的同名成员会隐藏掉父类中所有同名成员函数。</p>
<h4 id="多继承语法"><a href="#多继承语法" class="headerlink" title="多继承语法"></a>多继承语法</h4><p>c++允许一个类继承多个类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 子类 : 继承方式 父类<span class="number">1</span> , 继承方式 父类<span class="number">2</span> ....</span><br></pre></td></tr></table></figure>

<p>多继承可能会引发父类中有同名成员出现，需要加作用域区分。c++实际开发中不建议使用多继承。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> b=<span class="number">10</span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;base1.m&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> a=<span class="number">20</span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;base2.m&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base1,<span class="keyword">public</span> Base2&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">Son</span>().a &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; <span class="built_in">Son</span>().b &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">Son</span>().Base1::<span class="built_in">m</span>();</span><br><span class="line">	<span class="built_in">Son</span>().Base2::<span class="built_in">m</span>();<span class="comment">//记得加作用域</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h4><p>两个派生类继承同一个基类，又有某个类同时继承两个派生类。</p>
<p>菱形继承的时候，两个父类有相同数据，需要加以作用域区分。但是这相同的数据只要有一份即可，菱形继承导致数据有两份，资源浪费。</p>
<p>利用虚继承可以解决菱形继承的问题，在继承之前加上关键字 <code>virtual</code> 变为虚继承。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> B&#123; &#125;;</span><br></pre></td></tr></table></figure>

<p>这里的B叫做虚基类。</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><ul>
<li><p>静态多态</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Animal m&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> :<span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Cat m&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mm</span><span class="params">(Animal &amp;a)</span> </span>&#123;</span><br><span class="line">	a.<span class="built_in">m</span>();<span class="comment">//地址早绑定，编译阶段确定函数地址</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Cat cat;</span><br><span class="line">	<span class="built_in">mm</span>(cat);<span class="comment">//输出Animal，此处不管传入的是Animal的任何子类还是Animal，都会当成Animal</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态多态</p>
<p>子类重写父类的虚函数。</p>
<p>注意，重写和重载不一样，重写的返回值，形参列表和函数名都要一样。而重载只有函数名一样，参数列表可能不一样。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;<span class="comment">//虚函数</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Animal m&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> :<span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Cat m&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mm</span><span class="params">(Animal &amp;a)</span> </span>&#123;</span><br><span class="line">	a.<span class="built_in">m</span>();<span class="comment">//地址晚绑定，运行阶段确定函数地址</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Cat cat;</span><br><span class="line">	<span class="built_in">mm</span>(cat);<span class="comment">//输出Cat</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到动态多态和静态多态之间就差了一个<code>virtual</code>关键字。</p>
</li>
</ul>
<h4 id="原理剖析"><a href="#原理剖析" class="headerlink" title="原理剖析"></a>原理剖析</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样一个类，我们首先来测一下它的大小，明显是1.但是当我们加上<code>virtual</code>后，大小突变为4.这又是为什么呢？仔细思考可以发现，增加的大小应该是一个指针。它的名字叫做<code>vfptr</code>，全称 <code>virtual function pointer</code>（虚函数指针）这个指针会指向<code>vftable</code>，存放虚函数表，记录虚函数地址。当子类重写父类的函数，子类中的虚函数表内部会替换成子类的虚函数地址。</p>
<h4 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h4><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容，因此可以把虚函数改为纯虚函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual 返回值类型 函数名 (参数列表) =0;</span><br></pre></td></tr></table></figure>

<p><strong>纯虚函数与虚函数主要区别就是大括号变成了&#x3D;0</strong></p>
<p>当类中有了纯虚函数，这个类也成为抽象类。抽象类无法实例化对象，其子类必须重写抽象类中的纯虚函数，否则也属于抽象类</p>
<h4 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h4><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码。因此我们需要将父类中的析构函数改为虚析构或者纯虚析构。</p>
<p>下面看一个案例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> :<span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string* name;<span class="comment">//开辟在堆区的属性</span></span><br><span class="line">	<span class="built_in">Cat</span>(string name) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;小猫&quot;</span>&lt;&lt;*name&lt;&lt;<span class="string">&quot;说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	 ~<span class="built_in">Cat</span>() &#123;</span><br><span class="line">		<span class="keyword">if</span> (name != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;~Cat&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">delete</span> name;</span><br><span class="line">			name = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Animal* a = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">	a-&gt;<span class="built_in">speak</span>();</span><br><span class="line">	<span class="keyword">delete</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在cat类中增加了一个堆区的属性，我们在析构的时候需要同时将堆区开辟的内存销毁。但是当我们运行函数时，并没有出现“~Cat”的字样，也就说明没有析构成功，这是怎么回事呢？其实，父类指针在析构的时候，不会调用子类中的析构函数，子类如果有堆区的属性，就会造成内存泄漏。</p>
<p>我们只需要在Animal类中添加一个虚析构函数即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时我们也能增加一个纯虚析构函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，纯虚函数在子类必须得有一定的具体实现，我们可以直接在类的外面进行一个空的具体实现，如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Animal::~<span class="built_in">Animal</span>()&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这样，纯虚析构才算完成。而有了纯虚析构之后，这个类也属于抽象类，无法实例化对象。</p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>建立通用的模具，大大提高复用性。模板不能直接使用，它只是一个框架。</p>
<h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>泛型编程主要的技术就是模板。</p>
<p>函数模板就是建里一个通用函数，其函数返回值类型和形参类型可以不具体，用一个虚拟的类型来代表</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br></pre></td></tr></table></figure>

<p>当我们写一种复用需求很高的函数，比如两个数交换。但是c++中有很多数据类型，通常我们写的一种交换函数是不适用于另一种数据类型的，这时候我们可以使用模板来防止编写过多重复的函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">	T temp=a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的T就相当于一种数据类型，我们直接使用它创建变量。</p>
<p>而当我们需要调用的时候也有两种方式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//自动推导</span></span><br><span class="line"><span class="built_in">Swap</span>(a, b);</span><br><span class="line"><span class="comment">//指定类型</span></span><br><span class="line"><span class="built_in">Swap</span>&lt;<span class="type">int</span>&gt;(a, b);</span><br></pre></td></tr></table></figure>

<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li><p>自动类型推导必须要推导出一致的数据类型</p>
</li>
<li><p>模板必须要确定出T的数据类型，才可以使用</p>
<p>一个函数如果不含模板数据类型，那么无法调用这个函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//这种方式是不接受的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="普通函数与函数模板的区别"><a href="#普通函数与函数模板的区别" class="headerlink" title="普通函数与函数模板的区别"></a>普通函数与函数模板的区别</h4><ul>
<li><p>普通函数调用时可以发生自动类型转换（隐式类型转换）、</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码，当我们传入一个字符型变量和一个整型变量，也能得到结果，因为函数吟诗地将字符型转换为了整型（ASCLL码）</p>
</li>
<li><p>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果换成这种，就直接报错</p>
</li>
<li><p>如果利用显示指定类型的方式，可以发生隐式类型转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">cout&lt;&lt;<span class="built_in">add</span>&lt;<span class="type">int</span>&gt;(a, c);</span><br></pre></td></tr></table></figure>

<p>这样就指定系统为int类型，就可以转换啦</p>
</li>
</ul>
<h4 id="普通函数与函数模板调用规则"><a href="#普通函数与函数模板调用规则" class="headerlink" title="普通函数与函数模板调用规则"></a>普通函数与函数模板调用规则</h4><ul>
<li><p>如果普通函数和函数模板搜可以实现，优先调用普通用函数</p>
</li>
<li><p>可以通过空模板参数列表来强制调用模板函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; a * b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	fun&lt;&gt;(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加一个空的尖括号即可</p>
</li>
<li><p>函数模板也可以发生重载</p>
</li>
<li><p>如果函数模板可以产生更好的匹配，优先调用函数模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fun</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>还是上面的案例，如果我们这么写参数，那么会调用哪个函数呢？结果是函数模板，两个char类型可以更好地匹配函数模板，即便也能通过强制转换调用普通函数。</p>
</li>
</ul>
<h4 id="模板的局限性"><a href="#模板的局限性" class="headerlink" title="模板的局限性"></a>模板的局限性</h4><p>模板的重载可以为特定的类型提供具体的模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(Person a, Person b)</span> </span>&#123;<span class="comment">//注意！重载的语法</span></span><br><span class="line">	cout &lt;&lt; a.age + b.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码很好的提供了类和其他数据类型共用的模板函数。</p>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>类模板语法与函数模板类似。建立一个通用类，类中的成员和数据类型可以不具体指定，用一个虚拟的类型来代表。</p>
<h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">nameType</span>,<span class="keyword">class</span> <span class="title class_">ageType</span>&gt;<span class="comment">//两个属性，指定两个模板类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	nameType name;</span><br><span class="line">	ageType age;</span><br><span class="line">	<span class="built_in">Person</span>(nameType name, ageType age) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;jack&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>类模板与函数模板的区别主要有两点：</p>
<ul>
<li><p>类模板没有自动类型推导的方式</p>
</li>
<li><p>类模板在模板参数列表中可以有默认参数</p>
<p>还是上面的案例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">nameType</span>,<span class="keyword">class</span> <span class="title class_">ageType</span> = <span class="type">int</span>&gt;</span><br></pre></td></tr></table></figure>

<p>我们在定义模板的时候可以直接指定某个属性的数据类型，这样在我们实例化对象的时候可以直接省略该处的声明</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person&lt;string&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;jack&quot;</span>, <span class="number">18</span>)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="成员函数创建时机"><a href="#成员函数创建时机" class="headerlink" title="成员函数创建时机"></a>成员函数创建时机</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person show&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person1 show2&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T t;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		t.<span class="built_in">show</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		t.<span class="built_in">show2</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>来看代码，两个Person类我们先不看，我们创建一个A类，其中的属性t用的是模板类，但是系统目前不知道这个T表示的是哪个类，只要不创建对象就不会进入到函数体内，因此可以直接写<code>t.show()</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A&lt;Person1&gt;a;</span><br></pre></td></tr></table></figure>

<p>然后我们指定模板的类型为<code>Person1</code>，这时候就能识别成<code>Person1</code>的实例对象了，然后我们就能调用<code>Person1</code>中的<code>show2</code>函数了。值得注意的是，如果想要调用<code>Person</code>中的<code>show</code>函数，就会报错，因为类型为<code>Person1</code>与之不兼容。</p>
<h4 id="类模板对象做函数参数"><a href="#类模板对象做函数参数" class="headerlink" title="类模板对象做函数参数"></a>类模板对象做函数参数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">t1</span>,<span class="keyword">class</span> <span class="title class_">t2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	t1 name;</span><br><span class="line">	t2 age;</span><br><span class="line">	<span class="built_in">Person</span>(t1 name, t2 age) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>指定传入类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;string,<span class="type">int</span>&gt;&amp;p)</span> </span>&#123;<span class="comment">//注意参数列表。直接将类型告诉了编译器</span></span><br><span class="line">	p.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person&lt;string, <span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;jack&quot;</span>, <span class="number">18</span>);</span><br><span class="line">	<span class="built_in">printPerson</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数模板化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">t1</span>, <span class="keyword">class</span> <span class="title class_">t2</span>&gt;<span class="comment">//这个不能少</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;t1,t2&gt;&amp;p)</span> </span>&#123;</span><br><span class="line">	p.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类模板化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> t&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson3</span><span class="params">(t &amp;p)</span> </span>&#123;</span><br><span class="line">	p.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在开发中，最常用的还是第一种方式</p>
</li>
</ul>
<h4 id="类模板与继承"><a href="#类模板与继承" class="headerlink" title="类模板与继承"></a>类模板与继承</h4><p>当类模板遇到继承时，需要注意以下几点：</p>
<ul>
<li><p>当子类继承的父类是一个类模板，子类在声明的时候，要指定出父类中的类型，如果不指定，编译器无法给子类分配内存</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">t</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">	t num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base&lt;<span class="type">int</span>&gt; &#123;<span class="comment">//指定数据类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果想灵活指定出父类中的类型，子类也需要变成类模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">t</span>,<span class="keyword">class</span> <span class="title class_">t1</span>&gt;<span class="comment">//这里的t是父类中的模板，t1是子类中的模板</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> :<span class="keyword">public</span> Base&lt;t1&gt; &#123;</span><br><span class="line">	t1 num1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Son1&lt;<span class="type">int</span>,<span class="type">char</span>&gt;s;<span class="comment">//指定父类和子类中属性的类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="类模板成员函数类外实现"><a href="#类模板成员函数类外实现" class="headerlink" title="类模板成员函数类外实现"></a>类模板成员函数类外实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">t1</span>,<span class="keyword">class</span> <span class="title class_">t2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	t1 name;</span><br><span class="line">	t2 age;</span><br><span class="line">	<span class="built_in">Person</span>(t1 name, t2 age);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">t1</span>, <span class="keyword">class</span> <span class="title class_">t2</span>&gt;<span class="comment">//first</span></span><br><span class="line">Person&lt;t1, t2&gt;::<span class="built_in">Person</span>(t1 name, t2 age) &#123;<span class="comment">//second</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与普通类函数类外实现不同的是，这里首先要写上模板，然后还要加上Person的作用域，一定不要忘记尖括号里面的内容。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">t1</span>, <span class="keyword">class</span> <span class="title class_">t2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;t1, t2&gt;::<span class="built_in">show</span>() &#123;</span><br><span class="line">	cout &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他非构造函数也是如此。</p>
<h4 id="类模板分文件编写"><a href="#类模板分文件编写" class="headerlink" title="类模板分文件编写"></a>类模板分文件编写</h4><p>当一个文件中有非常多的类时，全部都写在这个文件显然是不合理的，会造成阅读源码的不适。我们可以考虑分文件编写，然后引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">t1</span>,<span class="keyword">class</span> <span class="title class_">t2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	t1 name;</span><br><span class="line">	t2 age;</span><br><span class="line">	<span class="built_in">person</span>(t1 name, t2 age);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">t1</span>, <span class="keyword">class</span> <span class="title class_">t2</span>&gt;</span><br><span class="line">person&lt;t1, t2&gt;::<span class="built_in">person</span>(t1 name, t2 age) &#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">t1</span>, <span class="keyword">class</span> <span class="title class_">t2</span>&gt;</span><br><span class="line"><span class="type">void</span> person&lt;t1,t2&gt;::<span class="built_in">show</span>() &#123;</span><br><span class="line">	cout &lt;&lt; name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person&lt;string, <span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;jack&quot;</span>, <span class="number">18</span>);</span><br><span class="line">	p.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个普通的类模板实现，现在我们将它分文件编写。</p>
<p>首先我们在头文件中添加一个名为Person.h的文件，用来存放类模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T1 name;</span><br><span class="line">	T2 age;</span><br><span class="line">	<span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以及在源文件中添加一个Person.cpp文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Person.h&quot;</span><span class="comment">//引用</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age) &#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">show</span>() &#123;</span><br><span class="line">	cout &lt;&lt; name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，我们将主函数中的类模板删去，再引用Person.cpp.为什么不能引用.h文件呢，直接引用h相当于少了一个函数的解析，而剩下的内容系统就不知道怎么继续进行下去了。</p>
<p>当然还有另外一种方式，就是将.cpp和.h的内容写到一起，改为hpp文件（约定俗称的文件后缀）</p>
<h4 id="类模板与友元"><a href="#类模板与友元" class="headerlink" title="类模板与友元"></a>类模板与友元</h4>
    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/02/06/MySQL%E5%9F%BA%E7%A1%80/" rel="prev" title="">
                  <i class="fa fa-angle-left"></i> 
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/02/06/%E8%83%8C%E5%8C%85dp/" rel="next" title="">
                   <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-java"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">XuSpring</span>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
