<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"right","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="放码过来">
<meta property="og:type" content="website">
<meta property="og:title" content="伊甸园">
<meta property="og:url" content="http://example.com/default-index/page/2/index.html">
<meta property="og:site_name" content="伊甸园">
<meta property="og:description" content="放码过来">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="XuSpring">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/default-index/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"default-index/page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>伊甸园</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">伊甸园</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">XuSpring's Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="XuSpring"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">XuSpring</p>
  <div class="site-description" itemprop="description">放码过来</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/06/Linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XuSpring">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="伊甸园">
      <meta itemprop="description" content="放码过来">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 伊甸园">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/06/Linux/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-06 15:52:06" itemprop="dateCreated datePublished" datetime="2025-02-06T15:52:06+08:00">2025-02-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-08-06 11:57:27" itemprop="dateModified" datetime="2024-08-06T11:57:27+08:00">2024-08-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="linux目录结构"><a href="#linux目录结构" class="headerlink" title="linux目录结构"></a>linux目录结构</h3><p>linux的目录结构是一个树形结构，win系统可以拥有多个盘符，但是linux没有盘符这个概念，只有一个根目录”&#x2F;“所有文件都在它下面。</p>
<p>在linux系统中，路径之间的层级关系使用”&#x2F;“来表示，而在win系统中，路径之间的层级关系使用“\”来表示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/hello.txt</span><br></pre></td></tr></table></figure>

<h3 id="linux命令入门"><a href="#linux命令入门" class="headerlink" title="linux命令入门"></a>linux命令入门</h3><h4 id="通用格式"><a href="#通用格式" class="headerlink" title="通用格式"></a>通用格式</h4><p>在linux中，命令都有其通用的格式：<code>command [-options][parameter] </code></p>
<ul>
<li>command：命令本身；</li>
<li>-options：可选（非必填） 命令的一些选项，可以通过选项控制命令的行为细节；</li>
<li>parameter：可选（非必填） 命令的参数，多数用于命令的指向目标。</li>
</ul>
<h4 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h4><p>ls命令的作用是列出目录下的内容</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> [-a -l -h][linux路径]</span><br></pre></td></tr></table></figure>

<p>如果直接使用ls命令本体，表示以平铺形式，列出当前工作目录下的内容（文件或文件夹）</p>
<p>当我们启动终端时，系统会默认将目录设置在用户的HOME目录。那么什么是HOME目录呢？每个Linux操作用户在linux系统的个人账户目录。win系统和linux系统均设有用户的HOME账户。</p>
<ul>
<li>命令中的参数</li>
</ul>
<p>​	路径中可以写上你想查看指定的文件夹，比如<code>ls /</code>表示查看根目录下的所有文件</p>
<ul>
<li><p>命令中的选项</p>
<p>-a：all的意思，即列出全部文件（包含隐藏的文件&#x2F;文件夹）只有通过-a选项才能看到隐藏文件或文件夹</p>
<p>-l：表示以列表<strong>竖向排列</strong>的形式展示内容b</p>
<p>-h：表示以易于阅读的形式列出文件的大小，比如Kb,Mb,Gb.注意，h一定要和l一起用才有作用</p>
</li>
</ul>
<p>语法中的选项是可以组合使用的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls -la</span><br><span class="line">ls -al</span><br><span class="line">ls -a -l</span><br></pre></td></tr></table></figure>

<p>这三种语法都是成立的</p>
<h4 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h4><p>更改当前所在的工作目录。cd命令来自英文（change directory）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd [linux命令]</span><br></pre></td></tr></table></figure>

<p>如果后面的参数不写，表示回到用户的HOME目录下面。写的话，就表示切换到对应的目录下去。</p>
<h4 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h4><p>展示当前所在的工作目录。pwd命令来自英文（print work directory）</p>
<p>pwd无选项，无参数，直接输入即可</p>
<h4 id="相对路径和绝对路径"><a href="#相对路径和绝对路径" class="headerlink" title="相对路径和绝对路径"></a>相对路径和绝对路径</h4><p>绝对路径是以<strong>根目录</strong>为起点，描述路径的一种写法，路径描述以&#x2F;开头</p>
<p>相对路径是以<strong>当前目录</strong>为起点，描述路径的一种写法，路径描述无需以&#x2F;开头</p>
<h4 id="特殊路径符"><a href="#特殊路径符" class="headerlink" title="特殊路径符"></a>特殊路径符</h4><p>. 表示当前目录，比如 <code>cd ./Desktop</code>表示切换到当前目录下的Desktop目录内，和cd Desktop效果一致</p>
<p>.. 表示上一级目录，比如 <code>cd ..</code>即可切换到上一级目录，<code>cd ../..</code>切换到上二级的目录</p>
<p>~ 表示HOME目录，比如<code>cd~</code>即可切换到HOME目录</p>
<h4 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h4><p>创建新的目录（文件夹）。mkdir命令来自英文（make directory）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir [-p] linux路径</span><br></pre></td></tr></table></figure>

<p>参数必填，即创建文件夹的路径，相对路径或绝对路径均可</p>
<p>-p可选，表示自动创建不存在的父目录，适用于创建连续多层级的目录。比如说</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p Desktop/1/2/3</span><br></pre></td></tr></table></figure>

<p>1、2和3文件夹都是之前没有的，如果不加-p，那么会报错，因为这些文件夹属于多层级的目录。</p>
<p>注意：创建文件夹需要修改权限，请确保操作均在HOME目录内</p>
<h4 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h4><p>创建文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch linux路径</span><br></pre></td></tr></table></figure>

<p>参数必填，即创建文件的路径，相对路径或绝对路径均可</p>
<h4 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h4><p>查看文件的内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat linux路径</span><br></pre></td></tr></table></figure>

<p>参数必填，即需要查看文件的路径，相对路径或绝对路径均可</p>
<h4 id="more命令"><a href="#more命令" class="headerlink" title="more命令"></a>more命令</h4><p>more同样可以查看文件内容，与cat不同的是cat是直接将内容全部显示出来。而more支持翻页。</p>
<p>more的语法与cat类似，这里就不过多赘述了。</p>
<h4 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h4><p>cp命令可以用于复制文件&#x2F;文件夹，cp命令来自英文单词：copy</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp [-r] 参数1 参数2</span><br></pre></td></tr></table></figure>

<p>-r：可选，用于复制文件夹使用，表示递归</p>
<p>参数1：linux路径，表示被复制的文件或文件夹</p>
<p>参数2：linux路径，表示要复制去的地方</p>
<h4 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h4><p>移动文件&#x2F;文件夹，mv命令来自英文单词：move</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv 参数1 参数2</span><br></pre></td></tr></table></figure>

<p>参数1：linux路径，表示被移动的文件或文件夹</p>
<p>参数2：linux路径，表示要移动去的地方，如果目标不存在，则进行改名</p>
<h4 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h4><p>删除文件&#x2F;文件夹，rm命令来自英文单词：remove</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm [-r -f] 参数1 参数2 ……参数N</span><br></pre></td></tr></table></figure>

<p>-r：删除文件夹</p>
<p>-f：表示force，强制删除，不会弹出提示确认信息</p>
<p>​	普通用户删除内容不会弹出提示，只有root管理员用户删除内容会有提示，所以一般用户	用不到-f选项</p>
<p>参数1、参数2……：表示要删除的文件或文件夹路径，按照空格隔开</p>
<p>通配符（*）：匹配任意内容</p>
<ul>
<li><code>aaa*</code>：表示匹配任意以aaa开头的内容</li>
<li><code>*aaa</code>：表示匹配任意以aaa结尾的内容</li>
<li><code>*aaa*</code>：表示匹配任何包含aaa的内容</li>
</ul>
<h4 id="which命令"><a href="#which命令" class="headerlink" title="which命令"></a>which命令</h4><p>查看所使用的一系列命令的程序文件存放在哪里</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">which 要查找的命令</span><br></pre></td></tr></table></figure>

<p>比如 <code>which cd</code>可以查看cd命令的程序文件存放的位置</p>
<h4 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h4><p>搜索指定文件</p>
<ul>
<li><p>按文件名查找</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find 起始路径 -name ”被查找文件名“</span><br></pre></td></tr></table></figure>

<p>同样，查找命令中也能使用通配符来做模糊匹配</p>
</li>
<li><p>按文件大小查找</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find 起始路径 -size +n [KMG]</span><br></pre></td></tr></table></figure>

<p>+&#x2F;-：表示大于和小于</p>
<p>n：表示大小数字</p>
<p>KMG：表示大小单位，kb&#x2F;mb&#x2F;gb</p>
<p>实例：<br>查找小于100kb的文件：find &#x2F; -size -10k</p>
</li>
</ul>
<h4 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h4><p>通过关键字过滤文件行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [-n] 关键字 文件路径</span><br></pre></td></tr></table></figure>

<p>-n：表示在结果中显示匹配和行的行号</p>
<p>关键字：表示过滤的关键字，带有空格或其他特殊符号，建议使用” “将关键字包围起来</p>
<p>文件路径：表示要过滤内容的文件路径，可作为内容输入端口</p>
<p>示例：</p>
<p>比如说我们在文档中写若干行文字，我们将 ”a“ 作为关键字，那么这行命令就会输出包含关键字 a 的所有行，并将关键字标红。此外，如果加上-n，那么会显示该句话的行数。</p>
<h4 id="wc命令"><a href="#wc命令" class="headerlink" title="wc命令"></a>wc命令</h4><p>统计文件的行数、单词数量等</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc [-c -m -l -w] 文件路径</span><br></pre></td></tr></table></figure>

<p>-c：统计bytes数量</p>
<p>-m：统计字符数量</p>
<p>-l：统计行数</p>
<p>-w：统计单词数量</p>
<p>文件路径：被统计的文件</p>
<h4 id="管道符（-）"><a href="#管道符（-）" class="headerlink" title="管道符（|）"></a>管道符（|）</h4><p>将管道符左边命令的结果作为右边命令的输入</p>
<h4 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h4><p>在命令行内输出指定内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 输出的内容</span><br></pre></td></tr></table></figure>

<p>如果内容带有空格或\等特殊符号，建议用双引号包围起来</p>
<h4 id="反引号（"><a href="#反引号（" class="headerlink" title="反引号（&#96;)"></a>反引号（&#96;)</h4><p>被它包围的内容将会作为命令执行</p>
<h4 id="重定向符"><a href="#重定向符" class="headerlink" title="重定向符"></a>重定向符</h4><p><code>&gt;</code>：将左边命令的结果覆盖写入到符号右侧的文件</p>
<p><code>&gt;&gt;</code>：将左侧命令的结果追加写入到符号右侧的文件</p>
<h4 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h4><p>查看文件尾部内容，跟踪文件的最新更改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail [-f -num] linux路径</span><br></pre></td></tr></table></figure>

<p>-f：表示持续跟踪。终端指令不会断掉，只要操作者做了更改，就立马会检测到文件的更改</p>
<p>-num：查看尾部多少行，不写默认为10行。注意-num在实际写的时候num要写成指定的数字</p>
<h4 id="vi-vim编辑器"><a href="#vi-vim编辑器" class="headerlink" title="vi&#x2F;vim编辑器"></a>vi&#x2F;vim编辑器</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>vi是visual interface的简称，是linux中最经典的文本编辑器。</p>
<p>vim是vi的加强版本，兼容vi的所有指令，不仅能编辑文本，还具有shell程序编辑的功能，以不同颜色的字体来辨别语法的正确性。</p>
<h5 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h5><ul>
<li><p>命令模式</p>
<p>所敲的按键编辑器都理解为命令，不能自由进行命令编辑</p>
</li>
<li><p>输入模式</p>
<p>对文件内容进行自由编辑</p>
</li>
<li><p>底线命令模式</p>
</li>
</ul>
<p>​		通常用于文件的保存退出</p>
<p>当我们进入vim时，默认进入到命令模式，可以通过一定的指令切换成输入模式。当然也可以从输入模式切换回命令模式。此外，还能通过命令模式进入底线命令模式。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/06/IO%E6%B5%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XuSpring">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="伊甸园">
      <meta itemprop="description" content="放码过来">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 伊甸园">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/06/IO%E6%B5%81/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-06 15:51:05" itemprop="dateCreated datePublished" datetime="2025-02-06T15:51:05+08:00">2025-02-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-09-12 16:45:54" itemprop="dateModified" datetime="2024-09-12T16:45:54+08:00">2024-09-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><p>流的概念：若干字节组成的一个字节序列，代表信息从源到目的的流动</p>
<p>IO流主要分为：标准输入输出流，字符流，文件流等等</p>
<h2 id="基本输入输出流"><a href="#基本输入输出流" class="headerlink" title="基本输入输出流"></a>基本输入输出流</h2><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>cin：标准输入，可以重定向。</p>
<p>cout：标准输出，可以重定向。</p>
<p>cerr：标准错误，不可重定向。</p>
<p>clog：标准出错，可以重定向。</p>
<h3 id="常用的函数"><a href="#常用的函数" class="headerlink" title="常用的函数"></a>常用的函数</h3><ul>
<li><p><code>put( )</code></p>
<p>输出字符。</p>
</li>
<li><p><code>get( )</code></p>
<p>输入字符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c1 = cin.<span class="built_in">get</span>();</span><br><span class="line">cout.<span class="built_in">put</span>(c1);<span class="comment">//实现一个简单的字符输入输出</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>write(streamsize n,char* s)</code></p>
<p>将一个字符数组的前n个字符写入流中。</p>
</li>
<li><p><code>getline(char* s, streamsize n)</code></p>
<p>从<code>istream</code>中读取至多m个字符（包含\0）保存在c对应的数组中。如果还没读够也会保存。能接收空格，用回车当作数据间隔；而cin没办法接收空格，以空格作为数据间隔。</p>
<p>此外，它还有一种重载形式：<code>getline(char* s, streamsize n,char delim)</code></p>
<p><code>delim</code>是指定的截断字符，如果遇到该字符，读取终止，且delim不会保存进s对应的数组中。</p>
<p>这里要注意了，<code>getline</code>函数在头文件<code>&lt;istream&gt;</code>and<code>&lt;string</code>均有。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c2[<span class="number">10</span>];</span><br><span class="line">cin.<span class="built_in">getline</span>(c2, <span class="number">5</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">cout.<span class="built_in">write</span>(c2, <span class="number">2</span>);<span class="comment">//简单测试样例</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="格式控制"><a href="#格式控制" class="headerlink" title="格式控制"></a>格式控制</h3><p><code>&lt;iomanip&gt;</code>库</p>
<p>用来对输入输出操作的格式进行更加方便的控制</p>
<table>
<thead>
<tr>
<th>控制符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>dec</td>
<td>设置整数为十进制</td>
</tr>
<tr>
<td>hex</td>
<td>设置整数为十六进制</td>
</tr>
<tr>
<td>oct</td>
<td>设置整数为八进制</td>
</tr>
<tr>
<td>setbase(n)</td>
<td>设置整数为n进制（n&#x3D;8，10，16）</td>
</tr>
<tr>
<td>setfill(c)</td>
<td>设置字符填充</td>
</tr>
<tr>
<td>setprecision(n)</td>
<td>设置浮点数的有效数字为n位</td>
</tr>
<tr>
<td>setw(n)</td>
<td>设置字段宽度为n位</td>
</tr>
<tr>
<td>setiosflags(ios::fixed)</td>
<td>设置浮点数以固定的小数位数显示</td>
</tr>
<tr>
<td>setiosflags(ios::scientific)</td>
<td>设置浮点数以科学计数法表示</td>
</tr>
<tr>
<td>setiosflags(ios::left)</td>
<td>输出左对齐</td>
</tr>
<tr>
<td>setiosflags(ios::right)</td>
<td>输出右对齐</td>
</tr>
<tr>
<td>setiosflags(ios::skipws)</td>
<td>忽略前导空格</td>
</tr>
<tr>
<td>setiosflags(ios::uppercase)</td>
<td>在以科学计数法输出E与十六进制输出X以大写输出，否则小写</td>
</tr>
<tr>
<td>setiosflags(ios::showpos)</td>
<td>输出正数时显示”+”号</td>
</tr>
<tr>
<td>setiosflags(ios::showpoint)</td>
<td>强制显示小数点</td>
</tr>
<tr>
<td>resetiosflags()</td>
<td>终止已经设置的输出格式状态，在括号中应指定内容</td>
</tr>
</tbody></table>
<h3 id="move"><a href="#move" class="headerlink" title="move"></a>move</h3><h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p><code>&lt;sstream&gt;</code></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/06/python/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XuSpring">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="伊甸园">
      <meta itemprop="description" content="放码过来">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 伊甸园">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/06/python/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-06 15:50:51" itemprop="dateCreated datePublished" datetime="2025-02-06T15:50:51+08:00">2025-02-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-10-29 16:24:11" itemprop="dateModified" datetime="2024-10-29T16:24:11+08:00">2024-10-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="python"><a href="#python" class="headerlink" title="python"></a>python</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>单行注释：#</p>
<p>多行注释：“”“ （三个引号）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"> 这是注释</span></span><br><span class="line"><span class="string"> 这是注释</span></span><br><span class="line"><span class="string"> 这是注释</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>type() 查看数据类型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="string">&quot;aaa&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>上面一段语句则会输出 字符串 数据类型 str</p>
<p>数据类型转换：int( ),float( ),str( )</p>
<p> 注意浮点数转换为整数会丢失小数</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul>
<li><p>定义</p>
<p>单引号，双引号以及三个引号都能定义</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="string">&#x27;aaa&#x27;</span></span><br><span class="line"><span class="built_in">str</span>=<span class="string">&quot;aaa&quot;</span></span><br><span class="line"><span class="built_in">str</span>=<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">aaa</span></span><br><span class="line"><span class="string">bbb</span></span><br><span class="line"><span class="string">ccc</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串格式化法1</p>
<p>占位符，记住后面一定要跟一个%(   )</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">num1=<span class="number">10</span></span><br><span class="line">num2=<span class="number">10.1</span></span><br><span class="line">ob1=<span class="string">&#x27;111&#x27;</span></span><br><span class="line">ob2=<span class="string">&#x27;222&#x27;</span></span><br><span class="line"><span class="built_in">str</span>=<span class="string">&quot;aaa=%s,bbb=%s&quot;</span>%(ob1,ob2)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line">str2=<span class="string">&quot;aaa=%d,bbb=%f&quot;</span>%(num1,num2)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br></pre></td></tr></table></figure>

</li>
<li><p>字符串格式化法2</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ob1=<span class="string">&#x27;111&#x27;</span></span><br><span class="line">ob2=<span class="string">&#x27;222&#x27;</span></span><br><span class="line">name=<span class="string">f&quot;aaa=<span class="subst">&#123;ob1&#125;</span>,bbb=<span class="subst">&#123;ob2&#125;</span>&quot;</span> <span class="comment">#前面的f不能忘记了</span></span><br><span class="line"><span class="built_in">print</span>(name)</span><br></pre></td></tr></table></figure>

<p>无视类型，但相比法1会丢失精度</p>
</li>
<li><p>格式化表达式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">res=<span class="string">f&quot;res=<span class="subst">&#123;<span class="number">1</span>+<span class="number">1</span>&#125;</span>&quot;</span></span><br><span class="line">res2=<span class="string">&quot;res=%d&quot;</span>%(<span class="number">1</span>+<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"><span class="built_in">print</span>(res2)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="数据输入"><a href="#数据输入" class="headerlink" title="数据输入"></a>数据输入</h3><p>input( )</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=<span class="built_in">input</span>(“请输入”) <span class="comment">#括号里就是输入之前的提示词</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，input的数据类型全部会当成字符串来看待，因此如果有其他数据类型的需要，可以将输入的“字符串”转换为相应的数据类型</p>
<h3 id="if-elif-else"><a href="#if-elif-else" class="headerlink" title="if elif else"></a>if elif else</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="built_in">input</span>()</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">elif</span>(i==<span class="number">2</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;else&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>注意冒号和缩进</p>
<h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="built_in">input</span>()</span><br><span class="line"><span class="keyword">while</span> i&lt;<span class="number">10</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h3 id="输出不换行"><a href="#输出不换行" class="headerlink" title="输出不换行"></a>输出不换行</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;aaa&quot;</span>,end=<span class="string">&#x27;&#x27;</span>) </span><br></pre></td></tr></table></figure>

<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><ul>
<li><p>字符串</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name=<span class="string">&quot;asdf&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> name:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>

<p>指i在字符串的域中，会依次输出每一个字符</p>
</li>
<li><p>range</p>
<p>range(num)：从0开始，到num结束的数字序列，不包括num本身</p>
<p>range(num1,num2)：从num1开始，到num2结束的数字序列，不包括num2本身</p>
<p>range(num1,num2,step)：获得一个从num1开始到num2结束的数字序列，数字之间的步长为step</p>
</li>
</ul>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">函数名</span>(<span class="params">参数</span>)</span><br><span class="line">	body</span><br><span class="line">	<span class="keyword">return</span> key <span class="comment"># 可省略</span></span><br></pre></td></tr></table></figure>

<p>无返回值的函数的类型为None</p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,....]</span><br><span class="line"><span class="built_in">list</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,...]</span><br><span class="line"><span class="comment">#空列表 </span></span><br><span class="line"><span class="built_in">list</span>=[]</span><br><span class="line">list1=<span class="built_in">list</span>() <span class="comment">#防止重名</span></span><br><span class="line"><span class="comment">#嵌套列表</span></span><br><span class="line">[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br></pre></td></tr></table></figure>

<p>列表的元素可以为不同的数据类型</p>
<ul>
<li><p>常用方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">列表.index(元素)</span><br></pre></td></tr></table></figure>

<p>查找指定元素的下标</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">列表.insert(下标，元素)</span><br></pre></td></tr></table></figure>

<p>在指定的下标位置，插入指定的元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">列表.append(元素)</span><br></pre></td></tr></table></figure>

<p>将指定元素追加到列表尾部</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">列表.extend(其他数据容器)</span><br></pre></td></tr></table></figure>

<p>将其他数据容器的内容取出，依次追加到列表尾部</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> 列表[下标]</span><br><span class="line">列表.pop(下标)</span><br><span class="line"><span class="comment">#两种语法</span></span><br></pre></td></tr></table></figure>

<p>删除列表</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">列表.remove(元素)</span><br></pre></td></tr></table></figure>

<p>删除某元素在列表中的第一个匹配项</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">列表.clear()</span><br></pre></td></tr></table></figure>

<p>清空列表</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">列表.count(元素)</span><br></pre></td></tr></table></figure>

<p>统计某元素在列表内的数量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>(列表)</span><br></pre></td></tr></table></figure>

<p>统计列表的长度</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/06/%E5%AE%B6%E5%BA%AD%E4%BB%BF%E7%9C%9F%E4%BB%A3%E7%A0%81%E6%B3%A8%E9%87%8A%E4%B9%8BRobot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XuSpring">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="伊甸园">
      <meta itemprop="description" content="放码过来">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 伊甸园">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/06/%E5%AE%B6%E5%BA%AD%E4%BB%BF%E7%9C%9F%E4%BB%A3%E7%A0%81%E6%B3%A8%E9%87%8A%E4%B9%8BRobot/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-06 15:50:45" itemprop="dateCreated datePublished" datetime="2025-02-06T15:50:45+08:00">2025-02-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-22 20:03:47" itemprop="dateModified" datetime="2025-01-22T20:03:47+08:00">2025-01-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Robot"><a href="#Robot" class="headerlink" title="Robot"></a>Robot</h1><h2 id="类介绍"><a href="#类介绍" class="headerlink" title="类介绍"></a>类介绍</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Robot</span> : <span class="keyword">public</span> Plug</span><br></pre></td></tr></table></figure>

<p>Robot是Plug的子类。</p>
<h3 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Object robot_plate, robot_hold;			<span class="comment">//机器人盘子里的物体（为0表示盘子空的），手（0表示空的）</span></span><br><span class="line">uint robot_location; 				   <span class="comment">//机器人的位置</span></span><br><span class="line">uint object_num; 				       <span class="comment">//物体数量</span></span><br><span class="line">string sexp_buf; 				       <span class="comment">//存储从服务器接收的s-expression形式的环境表</span></span><br><span class="line">vector&lt;Object&gt; vector_object; 		    <span class="comment">//存物体, 0为机器人 </span></span><br><span class="line">vector&lt;Instruction&gt; vector_ins; 		<span class="comment">//存指令</span></span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="AnalyseDomain"><a href="#AnalyseDomain" class="headerlink" title="AnalyseDomain"></a>AnalyseDomain</h3><p><strong>接受信息表里的信息，将它们储存在我们自己设定的容器中</strong>（预处理阶段）</p>
<p>domain：环境表结构体（可在global中看到）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//环境表结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">domain</span> &#123; 		<span class="comment">//从服务器获得的环境表元素基本结构</span></span><br><span class="line">	string keyword; 	<span class="comment">//关键字</span></span><br><span class="line">	string id; 			<span class="comment">//物体id</span></span><br><span class="line">	string other; 		<span class="comment">//其他信息，没有则在处理的时候直接不去处理</span></span><br><span class="line">	<span class="keyword">friend</span> std::ostream &amp; <span class="keyword">operator</span>&lt;&lt; (std::ostream &amp;os, <span class="type">const</span> domain &amp;dom); 		<span class="comment">//定义友元只为输出这个结构体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>domaintype:枚举类型（env和ins两种类型）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">DomainType</span> 			<span class="comment">//环境表和任务表中都含有domain结构体，所以会有不同的处理</span></span><br><span class="line">&#123;</span><br><span class="line">	DOMAINTYPE_NULL, 		</span><br><span class="line">	DOMAINTYPE_ENV, 		<span class="comment">//环境表中读取的</span></span><br><span class="line">	DOMAINTYPE_INS 			<span class="comment">//任务表中</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>chosen</code>标记当前正在处理 <code>domain</code> 的第几个字段。chosen先从1开始。由<code>(:domain (at 0 0) (sort 1 human) (hold 0))</code>可以看出，domain有三个字段。</p>
<p>如果 <code>sx</code> 非空，则跳到sx的下一个节点 。  </p>
<p>否则，遍历 S-expression 的每个节点，逐个处理内容。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    tmp_domain.keyword = sx_tmp-&gt;val;</span><br><span class="line">    sx_tmp = sx_tmp-&gt;next;</span><br><span class="line">    chosen++;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>若chosen为1，则是第一个字段，将第一个值赋值给 keyword</p>
</li>
<li><p>若chosen为2，将第二个值赋值给 id</p>
</li>
<li><p>若chosen为3， 将第三个值赋值给 other</p>
</li>
</ul>
<p>每次处理一个完整的 <code>domain</code>，将处理过的链表信息加入 <code>vector_tmp_domain</code>，然后重置chosen为1，将链表指针移动至下一个，继续循环，赋值判断。</p>
<p>最后这个函数返回值是domain类型的vector容器。</p>
<h3 id="DowithVectorDomain"><a href="#DowithVectorDomain" class="headerlink" title="DowithVectorDomain"></a>DowithVectorDomain</h3><p><strong>处理容器（vector_tmp_domain）信息里的每一项。</strong></p>
<p>如果domaintype为env（环境），将机器人先存到容器里，毕竟这个阶段肯定是没有其他物体的。</p>
<p>如果domaintype为instr（任务），肯定会有一个物体X，先将这个物体存到容器中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;domain&gt;::iterator pr;</span><br></pre></td></tr></table></figure>

<p>pr为表的迭代器，然后遍历所有表，如果某个物体的ID为Y，那么肯定是第二个物体，则再将它存到容器中。</p>
<h4 id="解析关键词"><a href="#解析关键词" class="headerlink" title="解析关键词"></a>解析关键词</h4><p><strong>注意：下列一切操作都是基于遍历链表的前提</strong></p>
<p>首先，将X和Y映射到对应vector_tmp_object容器的下标</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (domain_type == DOMAINTYPE_INS) &#123; 	</span><br><span class="line">			<span class="keyword">if</span> (pr-&gt;id == <span class="string">&quot;X&quot;</span>) 		<span class="comment">//是X用,magic number = 0, id与容器索引相关联</span></span><br><span class="line">				id = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (pr-&gt;id == <span class="string">&quot;Y&quot;</span>) 	<span class="comment">//Y, magic number = 1 </span></span><br><span class="line">				id = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>如果在指令语言下，vector_tmp_object[0]和vector_tmp_object[1]分别表示第一个物体和第二个物体。</p>
<p>如果在环境语言下，通过atoi函数（它的主要功能是将字符串转换为整数）将X和Y转换成整数，从而得到下标。</p>
<p>然后，检查一下vector_tmp_object的容量，如果它的容量vec_index比id还小，那么会引发数组越界错误，我们就需要在空缺的那一部分（id-vec_index）补充元素，防止越界。</p>
<p>下面，通过一个很多分支的if判断来分类关键词。</p>
<ul>
<li><p>如果keyword为sortx</p>
<p>如果是环境语言条件下，那么已经分配过了，于是需要一个空的Object对象tmp去给这个下标的数组内容占位，同时由于占了一个位置，容器的容量vecindex也需要加一。</p>
<p>这段代码主要的作用还是防止有些物体不是按照1234….顺序递增而导致的下标不符的错误。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (domain_type == DOMAINTYPE_ENV) &#123; 	<span class="comment">//如果是来自指令的则已经分配过了</span></span><br><span class="line">				vector_tmp_object.<span class="built_in">push_back</span>(tmp); 	<span class="comment">//如果是物体分配一个空间</span></span><br><span class="line">				<span class="keyword">if</span> (domain_type == DOMAINTYPE_ENV) </span><br><span class="line">					++vec_index;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>否则，根据物体的ID分配相应的种类，如HUMAN,PLANT,COUCH等等</p>
</li>
<li><p>如果keyword为at</p>
<p>更新位置</p>
<ul>
<li><p>如果id是0，代表机器人</p>
<p>at表示位置，因此需要更改机器人此刻的位置，使用SetLocation函数，atoi(other.c_str())表示解析位置，并转换成整数。</p>
</li>
<li><p>如果id不为0，是普通物体</p>
</li>
</ul>
</li>
<li><p>如果keyword为color</p>
<p>根据颜色分配相应的种类</p>
</li>
<li><p>如果keyword为type</p>
<p>分配container</p>
</li>
<li><p>如果keyword为inside</p>
<p>分配装在大物体里面的小物体</p>
<p>更改两个参数：inside参数和location参数，即小物体在哪个物体里面和小物体此刻的位置</p>
</li>
<li><p>如果keyword为on</p>
<p>分配物体的位置</p>
</li>
<li><p>如果keyword为near</p>
<p>分配物体的位置</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector_tmp_object[id].<span class="built_in">SetPosition</span>(vector_object[id].<span class="built_in">GetPosition</span>() | <span class="built_in">uint</span>(<span class="built_in">atoi</span>(other.<span class="built_in">c_str</span>()))); </span><br></pre></td></tr></table></figure>

<p>这段代码用到了或运算，为了是不覆盖原有的位置状态，合并表示多个位置关系</p>
</li>
<li><p>如果keyword为opened</p>
<p>分配门是开的状态</p>
</li>
<li><p>如果keyword为closed</p>
<p>分配门是关的状态</p>
</li>
<li><p>如果keyword为plate</p>
<ul>
<li><p>如果id&#x3D;0，没有物体</p>
</li>
<li><p>如果id不为0，有物体</p>
<p>先将物体的id记录在临时创建的Object类对象obj_tmp中，然后再根据obj_tmp设置机器人盘子里的物体。</p>
</li>
</ul>
</li>
<li><p>如果keyword为hold</p>
<p>跟上面plate的操作一致。</p>
</li>
</ul>
<h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>首先获得手里和盘子里的物体id。</p>
<p>如果手里的物体不为空，更新机器人手里的物体，将它的id设置成此处遍历到的物品id，然后再将物体的位置更新为机器人的位置。</p>
<p>盘子里的物体同上。</p>
<h3 id="StoreObject"><a href="#StoreObject" class="headerlink" title="StoreObject"></a>StoreObject</h3><p>传入信息表以及表的类型（env or ins）</p>
<p>将<code>vector_tmp_domain</code>容器中的信息按函数<code>DowithVectorDomain</code>的方法塞入<code>vector_tmp_object</code>容器。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<p>​                                                                                                   许春升  2025.1.22</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/06/%E5%AE%B6%E5%BA%AD%E4%BB%BF%E7%9C%9F%E4%BB%A3%E7%A0%81%E6%B3%A8%E9%87%8A%E4%B9%8BObject/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XuSpring">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="伊甸园">
      <meta itemprop="description" content="放码过来">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 伊甸园">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/06/%E5%AE%B6%E5%BA%AD%E4%BB%BF%E7%9C%9F%E4%BB%A3%E7%A0%81%E6%B3%A8%E9%87%8A%E4%B9%8BObject/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-06 15:50:45" itemprop="dateCreated datePublished" datetime="2025-02-06T15:50:45+08:00">2025-02-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-23 10:11:33" itemprop="dateModified" datetime="2024-12-23T10:11:33+08:00">2024-12-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object_all = <span class="number">0</span>; </span><br></pre></td></tr></table></figure>

<p>置0，创建一个新对象</p>
<h2 id="GetId"><a href="#GetId" class="headerlink" title="GetId()"></a>GetId()</h2><p>先通过 <code>object_all &amp; 0xff00000000000000</code>获取前八位的二进制码，其他位清零，然后再右移56位，即64-56&#x3D;8.所获取的tmp即代表着物品的id.</p>
<h2 id="SetId"><a href="#SetId" class="headerlink" title="SetId()"></a>SetId()</h2><p>先通过<code>object_all = object_all &amp; 0x00ffffffffffffff</code>将原来的object其他位保留，只消除原来的id位。</p>
<p><code>ulonglong(x) &lt;&lt; 56</code>其中x为输入，左移56位，获得<code> 0x_ _00000000000000</code>的形式。</p>
<p>最后，通过	<code>object_all = object_all | (ulonglong(x) &lt;&lt; 56)</code>将x的id位和原object的其他位保留，即完成了物品id的修改（设置）</p>
<h2 id="其他属性的get和set"><a href="#其他属性的get和set" class="headerlink" title="其他属性的get和set"></a>其他属性的get和set</h2><p>同理上面id的设置：</p>
<p>get都是先按位<strong>与</strong>运算，获取该属性的某一段二进制编码，再右移指定位数，获取属性的二进制码。</p>
<p>set都是先消除原来的属性位的二进制码，然后再将新的输入转换为64位形式，与原来的object按位<strong>或</strong>运算，结合了属性位和其他位，完成了属性的设置。</p>
<h2 id="Clear"><a href="#Clear" class="headerlink" title="Clear()"></a>Clear()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object_all = <span class="number">0</span>; 	</span><br></pre></td></tr></table></figure>

<p>与构造函数一样，都是置0，清除。</p>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object::<span class="keyword">operator</span>&lt;(<span class="type">const</span> Object &amp;x) <span class="type">const</span></span><br></pre></td></tr></table></figure>

<p>比较符重载，便于后面比较物品的优先级。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::ostream &amp; <span class="keyword">operator</span>&lt;&lt; (std::ostream &amp;os, <span class="type">const</span> Object &amp;obj)</span><br></pre></td></tr></table></figure>

<p>输出符<code>&lt;&lt;</code>重载，便于后面直接打印物品的所有属性，而不需要一个个单独调用get函数。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/06/%E6%88%90%E5%B9%B4%E5%89%8D%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E5%B0%81%E4%BF%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XuSpring">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="伊甸园">
      <meta itemprop="description" content="放码过来">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 伊甸园">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/06/%E6%88%90%E5%B9%B4%E5%89%8D%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E5%B0%81%E4%BF%A1/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-02-06 15:50:03 / 修改时间：15:45:16" itemprop="dateCreated datePublished" datetime="2025-02-06T15:50:03+08:00">2025-02-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="成年前的最后一封信"><a href="#成年前的最后一封信" class="headerlink" title="成年前的最后一封信"></a>成年前的最后一封信</h1><p> 发表于 2024-01-25</p>
<p>致L：</p>
<p>  成年来的还真慢啊，好不容易熬过了第十八个年头（十七还是十八，我数学不好）总算踏入了成年人的殿堂，</p>
<p>  虽然生日还没到，但礼物已经收到了，说实话我真的特别感动，这用心程度是我见过最好的一次了，去年那个糟糕的生日暂且不提，再往前看，生日我甚至给别人送礼物，离谱之离谱。以前深交的朋友也不是很多，他们不至于送我礼物的，也过惯了家里的生日，无非就是蛋糕加唱歌双重奏，儿时对蛋糕的渴望现在已变成稍稍厌恶了。</p>
<p>  啊啊啊啊啊啊啊啊啊啊啊真的很用心诶，特别是那封信，字真的很好看啊，还有画和立体字QAQ！！！艺术氛围拉满，很久没收到（或者说几乎没）手绘手写的贺卡了！！！（平复躁动的心）（深呼吸）（大脑飞速旋转）还有钢琴，我一开始以为是那种模型，我拆开盒子的第一下我就看到它了，但没想到按一下还真的发出声音来了，惊呆了！虽然我唱歌跑调但那不代表我弹琴跑调是吧，这回不需要库乐队了，整实物就好了！嘿嘿。我还是这个寒假买完大衣准备搞个项链戴戴的，怕不是你有读心术，这都悟出来了！！不得不说，款式酷酷的，妥妥机械风。</p>
<p>  然后吧，我想对自己一个总结，不是我自己的生活，而是我们俩之间的。这75天里小吵偶尔也有，有时是我嘴笨，又有时是我没考虑到，凡此种种，无非都是我道歉然后找出错误，又或者是你对我的期望从一开始的高逐渐变低直至失望，挺惭愧的，每次都说改变，到最后却还是这么个样子，总感觉没把每一件事做好，总感觉自己处处不着调，也不算是贬低自己吧，是对这些天来的一个深刻体悟。我觉得根本在于我没有把握好自我与二者之间的关系，我记得你之前说过你并不是在乎我怎么样怎么样好、成绩多好等等，山外有山、人外有人嘛，更在意的是我对你的态度。是这样的，我也尝试，慢慢尝试，做一件事想半天，虽然说最后导致的结局大差人意；嘴说不好话却又时常说岔嘴，惹得你生半天闷气。</p>
<p>  这么看来确实是我不成熟的体现，过了这么久我貌似发现是我给自己的学习压力太大了，也不知道能不能这么说，能给我个答复不？每天日复一日的算法，搞代码，头都敲昏了，但我也并不努力，我也玩，我现在对于自己的理解还是一知半解的，看似努力其实啥都没学到，我觉得你还是比较理性的（答复*2）你还记得放假前一天晚上吗，我难过的要死，其实并不是因为未来有多迷茫，以后怎么困难我心里清楚，但我们俩以后走的方向却是未知的，也许是不同的城市，也许是不同的学历，一想到这个我就更加迷茫，当然每个人走的路都是自己选择的，我肯定希望你考到更大的城市，我也想到更大的城市去工作，现在也做不了担保，我只能缓慢前行，迎难而上了。</p>
<p>  一份残缺而又浅显的总结算是写好了，语言组织的不是很好，真的太久没写这种信了，这也不算信，仿信。啊啊啊啊写的一塌糊涂，原谅我的章法……</p>
<p>​                                                               2024年1月25日</p>
<p>​                                                               许春升</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/06/%E5%AF%92%E5%81%87%E4%B9%8B%E7%BB%9D%E5%94%B1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XuSpring">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="伊甸园">
      <meta itemprop="description" content="放码过来">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 伊甸园">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/06/%E5%AF%92%E5%81%87%E4%B9%8B%E7%BB%9D%E5%94%B1/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-02-06 15:50:03 / 修改时间：15:44:18" itemprop="dateCreated datePublished" datetime="2025-02-06T15:50:03+08:00">2025-02-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="寒假之绝唱"><a href="#寒假之绝唱" class="headerlink" title="寒假之绝唱"></a>寒假之绝唱</h1><p> 发表于 2024-02-23</p>
<p>​    即将过期的寒假总是令人格外珍惜，即将步入的校园却也充满无限希望。</p>
<p>​    安徽的天气着实让人摸不着头脑，刚穿上的短袖还没有捂热乎就赶忙换上厚厚的羽绒袄子了。你要问我身体哪个部位最怕冷，我会毫不犹豫的回答：手！而偏偏手又是我日常用的最多的一个部位，导致冬日里干活不利索，属实是一件令人悲哀的故事。如此吸引我回学校的东西，恐怕就是学校里那全日制的空调了吧。打过年后，我就没有怎么学习了，一大堆数据结构还摆在计划单中呢，还有未完成的博客以及洛谷刷题……鉴于寒假余额已经不足，不如就好好收收心吧，等着开学再开展自己的计划。</p>
<p>​    这个寒假总的来说还是比较舒服的，相比高中那种极其压抑的寒假肯定自由不少，也做了不少充实的事情。相机陪我度过了绝大多数时间，反正就是到一个地方瞎拍拍，最后真正能出片的并没有几张。然后就是温习了数据结构，大一上学期学的匆匆忙忙的，好多地方都没顾及到，正好开学后面的学习也能稍微轻松一点。</p>
<p>2024-2-23</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/10/Java%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XuSpring">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="伊甸园">
      <meta itemprop="description" content="放码过来">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 伊甸园">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/01/10/Java%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">Java基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-01-10 21:41:44" itemprop="dateCreated datePublished" datetime="2024-01-10T21:41:44+08:00">2024-01-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-06 15:49:40" itemprop="dateModified" datetime="2025-02-06T15:49:40+08:00">2025-02-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>由于我是中途写的，所以我不知道标号是啥了，所以就先这么写吧</p>
<h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><h2 id="面向对象三大基本"><a href="#面向对象三大基本" class="headerlink" title="面向对象三大基本"></a>面向对象三大基本</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>好处：提高代码复用性，有利于代码的维护</p>
<p>多态是建立在封装和继承的基础之上的</p>
<h4 id="方法的多态"><a href="#方法的多态" class="headerlink" title="方法的多态"></a>方法的多态</h4><p>重写和重载就体现了多态</p>
<h4 id="对象的多态"><a href="#对象的多态" class="headerlink" title="对象的多态"></a>对象的多态</h4><ul>
<li>一个对象的编译类型和运行类型可以不一致</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"><span class="comment">//Animal是父类，Dog是子类</span></span><br></pre></td></tr></table></figure>

<p>animal的编译类型是Animal，运行类型是Dog。将父类的引用指向子类的对象</p>
<ul>
<li><p>编译类型在定义对象时就确定了，不能改变</p>
</li>
<li><p>运行类型是能改变的</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">animal =<span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br></pre></td></tr></table></figure>

<p>运行类型变为了Cat，编译类型仍然是Animal</p>
<ul>
<li>编译类型看等号的左边，运行类型看等号的右边</li>
</ul>
<p><strong>案例1</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物在叫唤&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小狗狗叫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小猫猫叫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Animal animal=<span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        animal.cry();</span><br><span class="line">        animal=<span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        animal.cry();<span class="comment">//重新指向</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候先输出狗叫，后输出猫叫</p>
<p><strong>案例2</strong></p>
<p>实现主人给动物喂食</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//改进前</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Food</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Food</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span> name=name;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Master</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Master</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Dog dog,Bone bone)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;主人&quot;</span>+name+<span class="string">&quot;给&quot;</span>+dog.getName()+<span class="string">&quot;喂&quot;</span>+bone.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bone</span> <span class="keyword">extends</span> <span class="title class_">Food</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bone</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Poly</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    Master master=Master(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">    Dog dog=Dog(<span class="string">&quot;大黄&quot;</span>);</span><br><span class="line">    Bone bone=Bone(<span class="string">&quot;骨头&quot;</span>);</span><br><span class="line">    master.feed(dog,bone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于改进方法，由于可能有多个动物，如果每一个动物都编写一个方法，显然过于繁琐。因此可以采用多态的方法来改进，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将feed方法这么改</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Animal animal,Food food)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;主人&quot;</span>+name+<span class="string">&quot;给&quot;</span>+animal.getName()+<span class="string">&quot;喂&quot;</span>+food.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>animal的编译类型是Animal，可以接受Animal子类的对象，food同理，因此在主方法里的dog和bone都可以传给animal和food</p>
<h4 id="多态的注意事项"><a href="#多态的注意事项" class="headerlink" title="多态的注意事项"></a>多态的注意事项</h4><ul>
<li><p>多态的前提是两个对象存在继承关系</p>
</li>
<li><p>向上转型，也叫做自动类型转换（父类的引用指向子类的对象）</p>
<p>可以调用父类的所有成员（属性和方法），但不能调用子类的特有成员。因为在编译阶段，能调用哪些成员是由编译类型来决定的</p>
<p>最终运行效果看子类的具体实现，即调用方法时，按照从子类开始查找方法，然后调用</p>
</li>
<li><p>向下转型，也叫做强制类型转换（将父类引用强制转换为子类引用）</p>
<p>只能强转父类的引用，不能强转父类的对象</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Methoda</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;a被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Methodb</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;b被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        A a=<span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        a.Methoda();</span><br><span class="line">        <span class="comment">//a.Methodb();这句话错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>    方法b不在编译类型A里，因此找不到方法b，报错</p>
<p>    解决办法：向下转型（公式：子类类型  引用名 &#x3D; (子类类型) 父类引用）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A a=<span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">B b=(B) a;</span><br><span class="line">b.Methodb();</span><br></pre></td></tr></table></figure>

<p>    也许读到这你就会疑惑了，为什么我不能直接 <code>B b=new B();</code>向下转型岂不是多此一举吗？</p>
<p>    每一种方法的创造必然有它的价值，向下转型亦如此。其实这么做是为了泛型编程而考虑的。<mark>这里由于知识匮乏，暂时找不出例子以及实现原理，待后续补充</mark></p>
<ul>
<li><p>属性没有重写之说</p>
<p>属性的值看编译类型</p>
</li>
<li><p><code>instanceof</code>比较操作符</p>
<p>java的保留关键字，测试左边的对象是否为右边的类或者其子类型，返回boolen数据类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        B b=<span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        System.out.println(b <span class="keyword">instanceof</span> B);</span><br><span class="line">        System.out.println(b <span class="keyword">instanceof</span> A);</span><br><span class="line">        System.out.println(b <span class="keyword">instanceof</span> Object);</span><br><span class="line">        A a=<span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        System.out.println(a <span class="keyword">instanceof</span> B);</span><br><span class="line">        System.out.println(a <span class="keyword">instanceof</span> A);</span><br><span class="line">        System.out.println(a <span class="keyword">instanceof</span> Object);</span><br><span class="line">        Object object=<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> A);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里空写了两个类，B继承A。对于b的编译类型属于A以及Object的子类型，前三个返回true。同理，中间三个也是返回true。对于最后一个，object的编译类型时Object不属于A的子类型，因此返回false</p>
<p><strong>案例3</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj=<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">9</span>);</span><br><span class="line">String str=(String)obj;</span><br></pre></td></tr></table></figure>

<p>运行该段代码会抛出异常<code>java.lang.Integer cannot be cast to java.lang.String</code>什么意思呢，是指int类型不能强转为String类型，这里属于向下转型，但是Integar与String不在同一个对象阶层，强制转换只会在同一个对象阶层转化</p>
<p>比如这里的B和C不属于同一阶层不能强制转换，而C和D属于同一阶层，可以强制转换<img title src="file:///C:/Users/ASUS/AppData/Roaming/marktext/images/2024-01-17-10-00-43-image.png" alt width="104" data-align="center"></p>
<h4 id="动态绑定机制"><a href="#动态绑定机制" class="headerlink" title="动态绑定机制"></a>动态绑定机制</h4><ul>
<li><p>当调用对象方法时，该方法会和该对象的内存地址（运行类型）绑定</p>
</li>
<li><p>当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用</p>
</li>
</ul>
<p>这两句话什么意思呢，下面看代码解读：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> i=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getl()+<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getl</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> i=<span class="number">20</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getl</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        A a=<span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        System.out.print(a.sum());</span><br><span class="line">        System.out.println(a.sum1());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果：30 30</span></span><br></pre></td></tr></table></figure>

<p>首先，a的运行类型是B，第一句话中的a.sum在B中没有此类方法，因此要去父类中找，于是跳转到A中的sum方法，但A中的sum方法的返回值中含有getl方法。我们看，A和B类中都有getl方法，这里是用到了方法重写，那么接下来程序会跳转到那个类的getl方法呢？显然是B中的，上文说过：一个方法会和该对象的运行类型绑定，a的运行类型是B，于是就调用了B类的getl，而B类中getl的i是属性，在B中声明为20，就使用B中给的值</p>
<p>上述程序很好的体现了上文所说的两句话</p>
<h2 id="多态的应用"><a href="#多态的应用" class="headerlink" title="多态的应用"></a>多态的应用</h2><ul>
<li>多态数组</li>
</ul>
<p>数组的定义类型为父类类型，里面保存的实际元素类型为子类类型</p>
<p>实现下列功能：创建Person、Student和Teacher对象，统一放在数组中，并调用say方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        <span class="built_in">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;名字是&quot;</span>+name+<span class="string">&quot; age=&quot;</span>+age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name,<span class="type">int</span> age,<span class="type">int</span> score)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name,age);</span><br><span class="line">        <span class="built_in">this</span>.score=score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">int</span> score)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.score=score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.say()+<span class="string">&quot; score=&quot;</span>+score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> salary;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">(String name,<span class="type">int</span> age,<span class="type">int</span> salary)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name,age);</span><br><span class="line">        <span class="built_in">this</span>.salary=salary;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSalary</span><span class="params">(<span class="type">int</span> salary)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.salary=salary;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSalary</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.say()+<span class="string">&quot; salary=&quot;</span>+salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        Person[] persons=<span class="keyword">new</span> <span class="title class_">Person</span>[<span class="number">5</span>];</span><br><span class="line">        persons[<span class="number">0</span>]= <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;sb1&quot;</span>,<span class="number">10</span>);</span><br><span class="line">        persons[<span class="number">1</span>]= <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;sb2&quot;</span>,<span class="number">20</span>,<span class="number">100</span>);</span><br><span class="line">        persons[<span class="number">2</span>]= <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;sb3&quot;</span>,<span class="number">18</span>,<span class="number">90</span>);</span><br><span class="line">        persons[<span class="number">3</span>]= <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;sb4&quot;</span>,<span class="number">50</span>,<span class="number">10000</span>);</span><br><span class="line">        persons[<span class="number">4</span>]= <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;sb5&quot;</span>,<span class="number">40</span>,<span class="number">20000</span>);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;persons.length;i++)&#123;</span><br><span class="line">            System.out.println(persons[i].say());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实，上述在调用say方法的时候启用了动态绑定，person[i]的编译类型为Person，而运行类型根据实际情况来看，new后面为什么就调用什么类里的方法</p>
<p>那么我们怎么调用子类中特有的方法呢，比如在Teacher里加一个teach方法，Student里加一个study方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(getName()+<span class="string">&quot;在授课&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(getName()+<span class="string">&quot;在听课&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 但是我们如果直接使用<code>persons[i].teach</code>或者<code>persons[i].study</code>，则会报错。我们看<code>Person[] persons=new Person[5]</code>这句话代表persons[i]的运行类型为Person，而在Person类里没有teach和study方法，编译器找不到，因此报错。</p>
<p>解决办法：向下转型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(persons[i] <span class="keyword">instanceof</span> Student)&#123;</span><br><span class="line">    ((Student)persons[i]).study();</span><br><span class="line"><span class="comment">//注意强转外面的括号不能忽略了，(Student)persons[i].study();是错误的写法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(persons[i] <span class="keyword">instanceof</span> Teacher)&#123;</span><br><span class="line">    ((Teacher)persons[i]).teach();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(persons[i] <span class="keyword">instanceof</span> Person)&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;类型有误&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要加一个判断，因为不知道persons的运行类型具体是什么，如果直接盲目强转会抛出异常。此外，对于Person的判断语句是一个空语句，没有实际操作。</p>
<ul>
<li>多态参数</li>
</ul>
<p>下面来看一个案例，能够很好地体现多态参数的含义</p>
<p>定义员工，普通员工和经理类。员工为父类，包含姓名和月工资，以及计算年工资的方法，经理类多了奖金属性和管理方法，普通员工类多了工作方法。</p>
<p>此外还有一个测试类，添加获取年工资的方法和判断员工种类的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> salary_month;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name,<span class="type">int</span> salary_month)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        <span class="built_in">this</span>.salary_month=salary_month;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSalary_month</span><span class="params">(<span class="type">int</span> salary)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.salary_month=salary;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSalary_month</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> salary_month;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAnnual</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">12</span>*salary_month;<span class="comment">//年工资等于月工资乘12</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Com_Employee</span> <span class="keyword">extends</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Com_Employee</span><span class="params">(String name,<span class="type">int</span> salary)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name,salary);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(getName()+<span class="string">&quot;正在工作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAnnual</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getAnnual();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> bonus;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">(String name,<span class="type">int</span> salary,<span class="type">int</span> bonus)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name,salary);</span><br><span class="line">        <span class="built_in">this</span>.bonus=bonus;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">manage</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(getName()+<span class="string">&quot;正在管理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAnnual</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getAnnual()+bonus;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        test t=<span class="keyword">new</span> <span class="title class_">test</span>();<span class="comment">//这句话容易忽略，容易写成test.方法();</span></span><br><span class="line">        Employee employee1=<span class="keyword">new</span> <span class="title class_">Com_Employee</span>(<span class="string">&quot;小A&quot;</span>,<span class="number">1000</span>);</span><br><span class="line">        Employee employee2=<span class="keyword">new</span> <span class="title class_">Com_Employee</span>(<span class="string">&quot;小B&quot;</span>,<span class="number">5000</span>);</span><br><span class="line">        Employee employee3=<span class="keyword">new</span> <span class="title class_">Manager</span>(<span class="string">&quot;小C&quot;</span>,<span class="number">10000</span>,<span class="number">200</span>);</span><br><span class="line">        System.out.println(t.showEmpAnnual(employee1));</span><br><span class="line">        t.testWork(employee1);</span><br><span class="line">        System.out.println(t.showEmpAnnual(employee2));</span><br><span class="line">        t.testWork(employee2);</span><br><span class="line">        System.out.println(t.showEmpAnnual(employee3));</span><br><span class="line">        t.testWork(employee3);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">showEmpAnnual</span><span class="params">(Employee e)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> e.getAnnual();<span class="comment">//动态绑定机制</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWork</span><span class="params">(Employee e)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(e <span class="keyword">instanceof</span> Manager)&#123;</span><br><span class="line">            ((Manager)e).manage();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(e <span class="keyword">instanceof</span> Com_Employee)&#123;</span><br><span class="line">            ((Com_Employee)e).work();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里注意，testwork和show方法内涵不同，前者是判断传入的实参到底为何种类型，进行向下转型，而后者为动态绑定机制，getAnnual取决于传入的实参的运行类型。</p>
<h2 id="Object类的几个简单方法"><a href="#Object类的几个简单方法" class="headerlink" title="Object类的几个简单方法"></a>Object类的几个简单方法</h2><h3 id="Equals"><a href="#Equals" class="headerlink" title="Equals"></a>Equals</h3><h4 id="Equals简介"><a href="#Equals简介" class="headerlink" title="Equals简介"></a>Equals简介</h4><p>equals方法是Object超类中的一个方法，默认情况下，比较内存地址是否相等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个A类</span></span><br><span class="line">A a=<span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">A b=<span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">System.out.println(a.equals(b));<span class="comment">//false</span></span><br><span class="line">System.out.println(a==b);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>如上，new了两个A类对象，因此地址元素不同，故返回false</p>
<p>如果将第二行语句改为<code>A b=a;</code>这时候返回true，两者内存地址相等</p>
<p>实际情况下，一般会重写equals方法，如String类的equals方法比较的是两个对象的内容，而不是内存地址</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String a=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">String b=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">System.out.println(a.equals(b));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>虽然new了两个String对象，但是由于String类的equals方法被重写，因此比较内容，返回true</p>
<h4 id="Equals与-的区别"><a href="#Equals与-的区别" class="headerlink" title="Equals与&#x3D;&#x3D;的区别"></a>Equals与&#x3D;&#x3D;的区别</h4><ul>
<li><p><code>==</code>主要用于基本类型之间的比较（int，char，boolen……）</p>
<p>当用于对象之间的比较是，主要以地址是否相等为判断标准</p>
</li>
<li><p><code>equals</code>主要用于对象之间的比较，可以通过重写equals方法来比较内容是否相同</p>
</li>
</ul>
<p>值得注意的是，基本数据类型不能使用equals用来判断</p>
<h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h3><p>返回该对象的哈希码值，提高哈希表的性能，这里仅做一个简单的介绍</p>
<ul>
<li><p>两个引用如果指向的是同一个对象，则哈希值肯定是一样的</p>
</li>
<li><p>两个引用如果指向的是不同对象，则哈希值是不一样的</p>
</li>
<li><p>哈希值主要根据地址号来的，不能将哈希值等价于地址</p>
</li>
</ul>
<h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h3><p>返回类名@哈希值的十六进制</p>
<h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A a=<span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">a=<span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>这里的a对象就是一个垃圾对象，垃圾回收器就会回收（销毁）对象，将其空间释放，供别的对象使用。</p>
<p>当然，也可以重写finalize方法，实现自己的逻辑，举个简单的重写例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Finalize</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        A a=<span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        a=<span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//System.gc();</span></span><br><span class="line">        System.out.println(<span class="string">&quot;程序结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;销毁&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;释放……&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在重写的finalize方法里写了两句话，当对象被销毁时，则会输出这两句话，而当我们运行代码的时候发现它并没有输出，这是怎么回事呢？跟算法有关，并不是说某个对象一变成垃圾就会被回收。有没有某种方式能够直接体现这种销毁的思想呢，当然有，在主方法里加一句<code>System.gc();</code>这句话表示运行垃圾回收器</p>
<pre><code>                        运行结果：程序结束
                        销毁
                        释放……              
</code></pre>
<p>这里肯定又有人疑惑了，明明System.gc()代码在结束先，不是应该先输入finalize方法里的语句吗？关于这个疑惑，咱后续再讲</p>
<p>在实际开发中，几乎用不到finalize，更多的是为了应付面试</p>
<h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><h1 id="第三章（面向对象高级部分）"><a href="#第三章（面向对象高级部分）" class="headerlink" title="第三章（面向对象高级部分）"></a>第三章（面向对象高级部分）</h1><h2 id="类变量和类方法"><a href="#类变量和类方法" class="headerlink" title="类变量和类方法"></a>类变量和类方法</h2><h3 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>类变量也叫静态变量， 定义在类中函数体之外的变量，可以被该类的所有对象实例共享，有static修饰。不加static修饰的称为实例变量&#x2F;普通变量&#x2F;非静态变量&#x2F;非静态成员变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class test01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        A a=new A();</span><br><span class="line">        A b=new A();</span><br><span class="line">        a.sum++;</span><br><span class="line">        b.sum++;</span><br><span class="line">        System.out.println(a.sum+&quot; &quot;+b.sum);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class A &#123;</span><br><span class="line">    static int sum=0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，a和b均为A类的实例，而sum为类变量，a和b共享，因此<code>a.sum++;</code>和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.sum++;`语句均使用一个sum，输出结果为`2 2</span><br></pre></td></tr></table></figure>

<h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><p>类变量在类加载的时候就生成了</p>
<p>（未完待续）</p>
<h4 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h4><p>对于上面的例子，还可以通过<code>A.sum</code>来访问类变量，即使没有创建对象实例。前提是满足访问修饰符的访问权限和范围。</p>
<h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><ul>
<li>实例对象不能通过<code>类名.变量名</code>访问</li>
<li>只要类加载了就能用类变量了</li>
<li>类变量的生命周期是随类的加载开始，随类的消亡而销毁</li>
</ul>
<h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><p>类方法的定义跟前面类变量定义同理</p>
<h4 id="具体使用场景"><a href="#具体使用场景" class="headerlink" title="具体使用场景"></a>具体使用场景</h4><p>当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法，提高开发效率。不创建实例也可以调用某个方法，如开发自己的工具类时，可以将方法做成静态的，方便调用</p>
<h4 id="细节-1"><a href="#细节-1" class="headerlink" title="细节"></a>细节</h4><ul>
<li>类方法中不允许使用和对象有关的关键字，比如<code>this</code>和<code>super</code></li>
<li>类方法只能访问静态变量或静态成员</li>
<li>普通成员方法，既可以访问非静态成员，也可以访问静态成员</li>
</ul>
<h3 id="main方法语法"><a href="#main方法语法" class="headerlink" title="main方法语法"></a>main方法语法</h3><ul>
<li>main方法是java虚拟机调用的，所以该方法必须得是public修饰</li>
<li>java虚拟机在执行main方法时无需创建对象，所以该方法必须是static</li>
<li>main方法接收string类型的数组参数，该数组保存执行java命令时传递给所运行的类的参数</li>
</ul>
<p>例如，我们可以通过下列方式来遍历该数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class A &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i;</span><br><span class="line">        for(i=0;i&lt;args.length;i++)&#123;</span><br><span class="line">            System.out.println(args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在main方法中，我们可以直接调用main方法所在类的静态属性和静态方法，但是不能直接访问该类中的非静态成员，必须创建该类的一个实例对象，才能通过这个对象去访问该类的非静态成员</li>
</ul>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>代码块又称为初始化块，属于类中的成员，类似方法，将逻辑语句封装在方法体中，通过{ }包围起来</p>
<p>但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显式调用，而是加载类时，或创建对象时隐式调用。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[修饰符]&#123;</span><br></pre></td></tr></table></figure>

<p>  <code>代码</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<ul>
<li>修饰符可写可不写，写的话只能写<code>static</code></li>
<li>有<code>static</code>修饰的叫静态代码块，否则叫作普通（非静态）代码块</li>
<li>分号可写可不写</li>
</ul>
<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><p>相当于对构造器的补充，用来初始化的操作，如果多个构造器中都有重复的语句，可以加到初始化块中，提高代码的复用性</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>把相同的语句放在一个代码块中，这样当我们调用构造器的时候，创建对象都会先调用代码块的内容</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>静态代码块只会执行一次，而普通代码块每创建一个对象就执行一次</li>
<li>类在什么时候被加载</li>
</ul>
<p><strong>1.创建对象实例</strong></p>
<p><strong>2.创建子类对象实例，父类会被加载</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class AA &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;父类代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class BB extends AA&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;子类代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AA aa = new BB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//运行结果：父类代码块</span><br><span class="line">//        子类代码块</span><br></pre></td></tr></table></figure>

<p>比如这里BB为AA 的子类， 两个类里均有代码块，当main方法里创建BB类对象时，会先输出父类代码块里的东西后输出子类代码块的东西</p>
<p><strong>3.使用类的静态成员</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class CC &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(dd.sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class dd&#123;</span><br><span class="line">    public static int sum=10;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;代码块&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//输出结果：代码块</span><br><span class="line">//         10 </span><br></pre></td></tr></table></figure>

<p>值得注意的是，如果我们把上面代码块前面的<code>static</code>去掉，则不会输出代码块里面的内容。只是使用类的静态成员，代码块不会被执行</p>
<ul>
<li>创建一个对象时，在一个类中的调用顺序</li>
</ul>
<p>1.调用静态代码块和静态属性初始化时，二者优先级相同，如果有多个静态代码块和多个静态属性初始化，则按照它们定义的顺序调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class A &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AA a=new AA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class AA&#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private static int n1=getN1();</span><br><span class="line">    public static int getN1()&#123;</span><br><span class="line">        System.out.println(&quot;getN1被调用&quot;);</span><br><span class="line">        return 10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是先调用静态代码块，再调用静态属性初始化，则输出结果为： <code>代码块</code></p>
<p>​                  <code>getN1被调用</code></p>
<p>如果将二者调换成如下顺序，那么输出结果将颠倒</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private static int n1=getN1();</span><br><span class="line">static &#123;</span><br><span class="line">        System.out.println(&quot;代码块&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.调用普通代码块和普通属性初始化时，同上，顺序依旧取决于定义的先后</p>
<p>3.当普通与静态混合使用时，静态代码块与属性初始化永远比普通代码块与属性要先执行，然后各自依照定义的顺序执行。此外， 构造器的优先级是最低的。现在我们补充一下上面的实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class AA&#123;</span><br><span class="line">    public AA()&#123;</span><br><span class="line">        System.out.println(&quot;构造器被调用&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private int n2=getN2();</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;普通代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public int getN2()&#123;</span><br><span class="line">        System.out.println(&quot;getN2被调用&quot;);</span><br><span class="line">        return 10;</span><br><span class="line">    &#125;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;静态代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private static int n1=getN1();</span><br><span class="line">    public static int getN1()&#123;</span><br><span class="line">        System.out.println(&quot;getN1被调用&quot;);</span><br><span class="line">        return 10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到新增了普通代码块和普通属性初始化，还有构造器。但运行后发现顺序正好相反。先输出“静态代码块”和“getN1被调用”，然后再输出“普通代码块”和“getN2被调用”，最后才输出“构造器被调用”。上面这段代码很好的诠释了三者之间的顺序。</p>
<p>那么在继承关系中，它们的顺序又是什么呢？那么就引出我们即将要说的内容了</p>
<ul>
<li>创建一个子类对象时，在父类与子类中的调用顺序</li>
</ul>
<p>还是老样子，先找静态，静态执行完之后再回去找普通。话不多说，上石山代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class A&#123;</span><br><span class="line">    private static int n1=getVal01();</span><br><span class="line">    static&#123;</span><br><span class="line">        System.out.println(&quot;A静态代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;A普通代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public int n3=getVal02();</span><br><span class="line">    public static int getVal01()&#123;</span><br><span class="line">        System.out.println(&quot;getVal01&quot;);</span><br><span class="line">        return 10;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getVal02()&#123;</span><br><span class="line">        System.out.println(&quot;getVal02&quot;);</span><br><span class="line">        return 10;</span><br><span class="line">    &#125;</span><br><span class="line">    public A()&#123;</span><br><span class="line">        System.out.println(&quot;A构造器&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A&#123;</span><br><span class="line">    private static int n3=getVal03();</span><br><span class="line">    static&#123;</span><br><span class="line">        System.out.println(&quot;B静态代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;B普通代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static int getVal03()&#123;</span><br><span class="line">        System.out.println(&quot;getVal03&quot;);</span><br><span class="line">        return 10;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getVal04()&#123;</span><br><span class="line">        System.out.println(&quot;getVal04&quot;);</span><br><span class="line">        return 10;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public B()&#123;</span><br><span class="line">        //super();</span><br><span class="line">        //注意一定不能忽略掉子类的suepr</span><br><span class="line">        System.out.println(&quot;B构造器&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>B类继承A，当我们在main方法中创建B类对象以后，调用顺序如下</p>
<ol>
<li>父类的静态代码块和静态属性初始化</li>
<li>子类的静态代码块和静态属性初始化</li>
<li>父类的普通代码块和普通属性初始化</li>
<li>父类的构造方法</li>
<li>子类的普通代码块和普通属性初始化</li>
<li>子类的构造方法</li>
</ol>
<p>一句话总结一下，先找静态，再找普通，每一次寻找的顺序都是由父类往子类找</p>
<ul>
<li>类处于继承关系时的顺序</li>
</ul>
<p>前面的知识中提到，创建一个类时，默认隐藏了<code>super</code>语句，如果父类中有代码块则先输出父类的代码块，这是容易忽略的一点，面试的高频考点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BB aa=new BB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class AA&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;AA代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public AA()&#123;</span><br><span class="line">        System.out.println(&quot;AA构造器&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class BB extends AA&#123;</span><br><span class="line">    //super();</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;BB代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public BB()&#123;</span><br><span class="line">        System.out.println(&quot;BB构造器&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显而易见，输出结果为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AA代码块</span><br><span class="line">AA构造器</span><br><span class="line">BB代码块</span><br><span class="line">BB构造器</span><br></pre></td></tr></table></figure>

<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="设计模式之【单例设计模式】"><a href="#设计模式之【单例设计模式】" class="headerlink" title="设计模式之【单例设计模式】"></a>设计模式之【单例设计模式】</h4><p>采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。下面我们来介绍两种简单的模式</p>
<ul>
<li>饿汉式</li>
</ul>
<p>​      1.构造器私有化</p>
<p>​      2.类的内部创建对象</p>
<p>​      3.向外暴露一个静态的公共方法</p>
<p>现在我们用代码实现该功能：一个人同时最多只能有一个女朋友</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class singleTest01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Girlfriend gf=Girlfriend.getInstance();</span><br><span class="line">        System.out.println(gf.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Girlfriend&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Girlfriend(String name)&#123;</span><br><span class="line">        this.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    private static Girlfriend gf=new Girlfriend(&quot;若兰&quot;);</span><br><span class="line">    public static Girlfriend getInstance()&#123;</span><br><span class="line">        return gf;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;name=&quot; + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于我们在构造器前面加上了private，在主方法new是行不通的，这也就避免了我们创建很多新对象。然后我们在此类里创建了一个新对象，但此时我们还不能在主方法里直接调用，需要用到另一个公共static方法：getInstance，返回该对象，这样我们就能在主方法里调用了。要注意这里的个体Instance方法的返回类型是类名。</p>
<p>但是，饿汉式还有个缺点，无论你有没有用到这个实例对象，饿汉式都会创建，这时候可能会造成资源浪费，下面我们的懒汉式就能很好解决这个问题了</p>
<ul>
<li>懒汉式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class singleTest01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Girlfriend.n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Girlfriend&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    public static int n=1;</span><br><span class="line">    private Girlfriend(String name)&#123;</span><br><span class="line">        this.name=name;</span><br><span class="line">        System.out.println(&quot;构造器被调用&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private static Girlfriend gf;//默认为空</span><br><span class="line">    public static Girlfriend getInstance()&#123;</span><br><span class="line">        if(gf==null)&#123;</span><br><span class="line">           gf=new Girlfriend(&quot;若兰&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;getInstance被调用&quot;);</span><br><span class="line">        return gf;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是上面的案例，这里我们新创建了一个静态属性，众所周知当使用静态属性的时候默认加载这个类，但结果并没有<code>“输出构造器被调用”</code>以及<code>“getInstance被调用“</code>，这说明懒汉式并不自动创建实例对象，只有使用<code>getInstance</code>方法才会返回该对象，再次调用时，会返回上次创建的对象。不会造成资源的浪费</p>
<ul>
<li>区别</li>
</ul>
<p>1.二者最主要的区别就是在于创建对象的时机不同：饿汉式是在类加载就创建了对象实例，而懒汉式实在使用时才创建</p>
<p>2.饿汉式不存在线程安全问题，懒汉式存在线程安全问题</p>
<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><h3 id="使用情况"><a href="#使用情况" class="headerlink" title="使用情况"></a>使用情况</h3><ul>
<li>不希望类被修饰，可以用final修饰</li>
<li>不希望父类的某个方法被子类覆盖&#x2F;重写，可以用final修饰</li>
<li>不希望类的某个属性的值被修改，可以用final修饰</li>
<li>当不希望某个局部变量被修改，可以用final修饰</li>
</ul>
<h3 id="细节-2"><a href="#细节-2" class="headerlink" title="细节"></a>细节</h3><ul>
<li>final修饰的属性又叫常量</li>
<li>final修饰的属性在定义时，必须赋初值，且不能再修改，赋值可以在如下位置之一</li>
</ul>
<p>​      1.定义时</p>
<p>​      2.在构造器中</p>
<p>​      3.在代码块中</p>
<ul>
<li>如果final修饰的属性是静态的，则初始化的位置只能是定义和静态代码块中，不能在构造器中赋值</li>
<li>final类不能被继承，但可以实例化对象</li>
<li>如果类不是final类，但是含有final方法，此方法虽然不能重写，但可以继承</li>
<li>一般来说如果一个类已经是final类了，不需要再将其方法用final修饰</li>
<li>final不能修饰构造器</li>
<li>final和static往往搭配使用，效率更高，不会导致类加载</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class test01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(A.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class A&#123;</span><br><span class="line">   static final int a=100;</span><br><span class="line">   static&#123;</span><br><span class="line">       System.out.println(&quot;代码块&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般来说当调用A类静态属性会加载整个类，但这里我们将属性用final修饰，可以做到仅仅调用这个属性而不加载类，从而提高效率</p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>所谓的抽象方法就是没有实现的方法，没有方法体。当一个类中存在抽象方法时，需要将该类声明为抽象类。一般来说，抽象类会被继承，由其子类来实现抽象方法</p>
<h3 id="细节-3"><a href="#细节-3" class="headerlink" title="细节"></a>细节</h3><ul>
<li>语法：<code>abstract 方法名</code>注意后面不能加花括号，没有方法体</li>
<li>抽象类的价值更多是设计，设计者设计好后，让子类实现，在框架用的较多</li>
<li>抽象类不能被实例化</li>
<li>抽象类可以有任意成员，比如非抽象方法、构造器、静态属性等等，不一定要包含abstract方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">abstract class A&#123;</span><br><span class="line">    private int a;</span><br><span class="line">    public A()&#123;</span><br><span class="line">        this.a=a;</span><br><span class="line">        System.out.println(&quot;这是构造器&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void B()&#123;</span><br><span class="line">        System.out.println(&quot;...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>abstract</code>只能修饰类和方法，不能修饰属性或其他的</li>
<li>如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，否则将自己声明为abstract类</li>
<li>抽象方法不能使用private、final和static来修饰，因为这些关键字都是和重写相违背的</li>
</ul>
<h3 id="实践-设计模式之【模板设计模式】"><a href="#实践-设计模式之【模板设计模式】" class="headerlink" title="实践-设计模式之【模板设计模式】"></a>实践-设计模式之【模板设计模式】</h3><p>假设现在我们要实现这么一个方法，有很多类，每个类包含几个方法，统计这些方法运行的时间</p>
<h4 id="基础版"><a href="#基础版" class="headerlink" title="基础版"></a>基础版</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class A &#123;</span><br><span class="line">    public void job()&#123;</span><br><span class="line">        long sum=0;</span><br><span class="line">        long start=System.currentTimeMillis();//统计当前时间</span><br><span class="line">        for(int i=1;i&lt;=10000000;i++)&#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        long end=System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;运行时间为:&quot;+(end-start));</span><br><span class="line">        //前后时间一减就是运行时间</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        A a=new A();</span><br><span class="line">        a.job();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们就写了一个类，其他的类同理。但我们会发现一个问题，倘若要写很多类，每一个类的方法中我们都要写一个统计时间的代码，那将很耗费时间。能不能改进呢？当然，就用到了所谓的“模板设计模式”</p>
<h4 id="终极版"><a href="#终极版" class="headerlink" title="终极版"></a>终极版</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public abstract class tamplate &#123;</span><br><span class="line">    public abstract void job();//抽象方法</span><br><span class="line">    public void time()&#123;//非抽象方法</span><br><span class="line">        long sum=0;</span><br><span class="line">        long start=System.currentTimeMillis();</span><br><span class="line">        job();</span><br><span class="line">        long end=System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;运行时间为:&quot;+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class A extends tamplate&#123;</span><br><span class="line">    public void job()&#123;</span><br><span class="line">        long sum=0;</span><br><span class="line">        for(int i=1;i&lt;=10000000;i++)&#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        A a=new A();</span><br><span class="line">        a.time();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们将计算时间集成为一个方法，放在抽象类tamplate中，此外还有一个抽象方法job。当我们创建一个新类并继承tamplate时，需要对job方法重写，这样我们就不需要在每个方法体中编写计算时间的代码了，大大降低了繁琐程度</p>
<p>注意，这里运用到了动态绑定机制，当我们在主方法中调用time时，会先从子类中找有没有这个方法，然后在父类中寻找，当运行到time方法中的job时，会与运行类型绑定，自然就跳转到该运行类型的job方法中去了</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，再根据具体情况把这些方法写出来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">interface itf&#123;</span><br><span class="line">    public int a=100;</span><br><span class="line">    public void A();</span><br><span class="line">    default public void B()&#123;</span><br><span class="line">        System.out.println(&quot;实现方法&quot;);</span><br><span class="line">    &#125;//可以使用默认方法，需要使用default关键字修饰</span><br><span class="line">    public static void C()&#123;</span><br><span class="line">        System.out.println(&quot;实现方法&quot;);</span><br><span class="line">    &#125;//或者使用静态方法，用static修饰</span><br><span class="line">&#125;</span><br><span class="line">class AA implements itf&#123;</span><br><span class="line">    public void A()&#123;</span><br><span class="line">        System.out.println(&quot;实现方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：在jdk7以前，接口里的所有方法都没有方法体，即都是抽象方法；而在jdk8以后接口类可以有静态方法，默认方法，也就是说接口中可以有方法的具体实现</strong></p>
<h1 id="枚举和注解"><a href="#枚举和注解" class="headerlink" title="枚举和注解"></a>枚举和注解</h1><h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>按照传统思路去写只拥有几个固定属性的对象（如季节等）是不适合的，因为能随意修改。我们引入了枚举类。</p>
<p>枚举是一组常量的集合，是一种特殊的类，里面只包含一组有限的特定的对象。</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ul>
<li><p>自定义类实现枚举</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumerationClass01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(season.SPRING.getName()+<span class="string">&quot; &quot;</span>+season.SPRING.getDesc());</span><br><span class="line">        System.out.println(season.SUMMER.getName()+<span class="string">&quot; &quot;</span>+season.SUMMER.getDesc());</span><br><span class="line">        System.out.println(season.AUTUMN.getName()+<span class="string">&quot; &quot;</span>+season.AUTUMN.getDesc());</span><br><span class="line">        System.out.println(season.WINTER.getName()+<span class="string">&quot; &quot;</span>+season.WINTER.getDesc());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">season</span>&#123;</span><br><span class="line">    <span class="comment">//构造器私有化，防止在外部直接新建（new）</span></span><br><span class="line">    <span class="comment">//去掉set（只读）防止属性被修改</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">    <span class="comment">//优化，加入final修饰</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">season</span> <span class="variable">SPRING</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">season</span>(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;温暖&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">season</span> <span class="variable">SUMMER</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">season</span>(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;炎热&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">season</span>(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;凉爽&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">season</span> <span class="variable">WINTER</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">season</span>(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;寒冷&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">season</span><span class="params">(String name,String desc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.desc=desc;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了防止随意修改属性，我们将原本的<code>setXXX</code>方法删去，只提供<code>getXXX</code>方法，即只读。通常对枚举对象&#x2F;属性使用final+static修饰（对外暴露对象），以实现底层优化。枚举对象名通常全部使用大写，常量的命名规范。</p>
</li>
<li><p><code>enum</code>关键字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">season2</span>&#123;</span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;温暖&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;炎热&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;凉爽 &quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;寒冷&quot;</span>);<span class="comment">//写在前面，多个对象要用用逗号隔开</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">season2</span><span class="params">(String name,String desc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.desc=desc;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本语法与上面略有不同，不过本质上都是类似的。值得注意的是，在这里 如果有多个枚举对象，需要用逗号隔开。还有就是枚举对象要写在最前面。</p>
<p>当我们通过<code>javap</code>反编译class文件时，会发现我们用<code>enum</code>写的枚举类默认继承<code>Enum</code>类，而且是一个final类。</p>
</li>
</ul>
<p>![屏幕截图 2024-06-04 200518](C:\Users\ASUS\Desktop\枚举和注解\屏幕截图 2024-06-04 200518-1717502927844-2.png)</p>
<p>​     如果使用无参构造器创建枚举对象，则实参列表和小括号都可以省略</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DAY();<span class="comment">//DAY;</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> String desc;</span><br><span class="line"><span class="keyword">private</span> <span class="title function_">season2</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="enum常用方法"><a href="#enum常用方法" class="headerlink" title="enum常用方法"></a>enum常用方法</h3><p>这里我们还是用上面<code>season2</code>这个枚举类。</p>
<ul>
<li><p><code>name()</code></p>
<p>输出枚举对象的名字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">season2 spring=season2.SPRING;<span class="comment">//SPRING</span></span><br><span class="line">System.out.println(spring.name());</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ordinal()</code></p>
<p>输出该枚举对象的次序，第一个为0，第二个为1，以此类推……</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(spring.ordinal());<span class="comment">//0</span></span><br></pre></td></tr></table></figure>

<p>由于我们的spring是第一个枚举对象，因此输出0.同理如果后面跟着<code>summer</code>，则输出1.</p>
</li>
<li><p><code>values()</code></p>
<p>返回含有所有定义的枚举对象的数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">season2 v[]=spring.values();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">    System.out.println(v[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的v就包含了四个季节。</p>
</li>
<li><p><code>valueOf()</code></p>
<p>根据输入的字符串再所有枚举对象中查找，如果找到了就返回，没有找到就报错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">season2 spring2=season2.valueOf(<span class="string">&quot;SPRING&quot;</span>);</span><br><span class="line">System.out.println(spring==spring2);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>注意这里的<code>pring2</code>和上文提到的spring是一个东西，当我们判断它们是否相等时，输出<code>true</code>，可以验证。如果我们将后面的”<code>SPRING</code>“改为”<code>SPING</code>“那么系统找不到，就报错。</p>
</li>
<li><p><code>compareTo()</code></p>
<p>把两个对象的序号比较，返回的结果为前面的序号与后面的序号之差。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(season2.SPRING.compareTo(season2.AUTUMN));</span><br></pre></td></tr></table></figure>

<p><code>SPRING</code>的序号为0，<code>AUTUMN</code>的序号为2，因此输出结果为-2.</p>
</li>
</ul>
<h3 id="enum实现接口"><a href="#enum实现接口" class="headerlink" title="enum实现接口"></a><code>enum</code>实现接口</h3><ul>
<li><p>使用<code>enum</code>关键字就不能继承其他的类了，因为<code>enum</code>隐式继承了<code>Enum</code>，而Java是单继承机制</p>
</li>
<li><p>枚举类实现接口如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumExercise02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        A.MEIJU.m();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">AA</span>&#123;</span><br><span class="line">    MEIJU;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>注解也被称为元数据，用于修饰解释包、类、方法、属性、构造器和局部变量等数据信息。</p>
<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>使用Annotation时要在其前面增加@符号，并把该Annotation当成一个修饰符使用，用于修饰它支持的程序元素。</p>
<p>下面介绍三个基本的Annotation：</p>
<ul>
<li><p><code>@Override</code></p>
<p>限定某个方法，重写父类方法，该注解只能用于方法。如果写了<code>@Override</code>注解，编译器就会去检查该方法是否真的重写了父类的方法，如果重写了，编译通过，否则编译错误。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="meta">@java</span>.lang.Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Override</code>只能修饰方法，不能修饰其他类、包、属性等。</p>
</li>
<li><p><code>@Deprecated</code></p>
<p>用于表示某个程序元素（类，方法等）已经过时。可以修饰方法、包、类、字段、参数等等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@java</span>.lang.Deprecated</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A1</span>&#123;<span class="comment">//过时不是不能用，只是不推荐使用</span></span><br><span class="line">    <span class="meta">@java</span>.lang.Deprecated</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> n1=<span class="number">1</span>;</span><br><span class="line">    <span class="meta">@java</span>.lang.Deprecated</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以做版本升级过渡使用。</p>
</li>
<li><p><code>@SuppressWarnings</code></p>
<p>当我们不希望看到警告的时候，可以用<code>@SuppressWarnings</code>来抑制警告信息。在{“ “}中，可以写入你希望抑制的警告信息。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br></pre></td></tr></table></figure>

<p>​	<code>@SuppressWarnings</code>抑制的范围和你放置的位置相关。</p>
</li>
</ul>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>元注解为修饰注解的注解。</p>
<p>元注解主要分为</p>
<ul>
<li><p>@Retention</p>
<p>只能修饰注解定义，用于指定该注解可以保留多长时间。 </p>
</li>
<li><p>@Target</p>
<p>用于修饰注解定义，用于指定被修饰的注解能用于哪些程序元素。</p>
</li>
<li><p>@Document</p>
<p>用于指定被改元注解修饰的注解类将被<code>javadoc</code>工具提取成文档，在文档中显示。</p>
</li>
<li><p>@Inherited</p>
<p>被他修饰的注解将具有继承性。如果某个类使用了被@Inherited修饰的注解，则其子类将自动具有该注解。</p>
</li>
</ul>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>​	Java语言中，将程序执行中发生的不正常情况称为“异常”，但开发过程中的语法错误和逻辑错误不是异常。</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li><p><code>Error</code>：Java虚拟机无法解决的严重问题。比如系统内部错误，资源耗尽（栈溢出，内存不足等等），Error是严重错误，程序会崩溃</p>
</li>
<li><p><code>Exception</code>：其他因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。分为两大类：</p>
<ul>
<li>运行时异常（程序运行时，发生的异常）程序员应该避免其出现这样的异常，编译器检查不出来，这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响。</li>
<li>编译时异常（编程时，编译器检查出的异常）编译器要求必须处置的异常。</li>
</ul>
</li>
</ul>
<h2 id="常见的运行时异常"><a href="#常见的运行时异常" class="headerlink" title="常见的运行时异常"></a>常见的运行时异常</h2><ul>
<li><p><code>NullPointException</code>空指针异常：</p>
<p>​	当应用程序试图在需要对象的地方使用null时，抛出该异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NullPointException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String name=<span class="literal">null</span>;</span><br><span class="line">        System.out.println(name.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	这里我们输出了一个空字符串的长度，显然是错误的，就会抛出<code>Exception in thread &quot;main&quot; java.lang.NullPointerException</code>的异常。</p>
</li>
<li><p><code>ArithmeticException</code>数学运算异常：</p>
<p>​	当出现异常的运算条件时，比如一个数除以0等等，就会抛出该异常。</p>
</li>
<li><p><code>ArrayIndexOutOfBoundsException</code>数组越界异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayIndexOutOfBoundsException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[]a=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];</span><br><span class="line">        System.out.println(a[<span class="number">6</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抛出<code>Exception in thread &quot;main&quot; java.lang.ArrayIndexOutOfBoundsException</code></p>
</li>
<li><p><code>ClassCastException</code>类型转换异常：</p>
<p>​	当试图将对象强制转换为一个不是实例的子类时，抛出该异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassCastException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        A b=<span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        B b1=(B)b;</span><br><span class="line">        C b2=(C)b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>​	主方法中第二条语句的向下转型是对的，因为b的运行类型本来就是B.而第三条语句中的向下转型明显就是两个无关的类（B和C）故抛出异常。</p>
</li>
<li><p><code>NumberFormatException</code>数字格式不正确异常</p>
<p>​	当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumberFormatException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String name=<span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">        <span class="type">int</span> num=Integer.parseInt(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们不能将一个字母类型的字符串转换成整数类型，因此抛出异常。</p>
</li>
</ul>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>异常处理的方式</p>
<ul>
<li><p>try-catch-finally</p>
<p>​	如果认为一段代码有异常抛出，可以用以下代码捕获异常。系统将异常封装成Exception对象e，传递给catch.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">	<span class="comment">//捕获到异常</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">	<span class="comment">//不管try代码块是否有异常发生，始终要执行finally</span></span><br><span class="line">    <span class="comment">//主要用来资源的关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	如果没有发生异常，catch代码块不执行，但是finally仍然执行。如果没有finally也可以。</p>
<p>​	如果发生了异常，则异常后面的代码不会执行，直接进入到catch块，如果有finally，最后还需要执行finally里面的语句。比如下面的例子，在<code>Integer.parseInt(name)</code>处遇到了异常，那么我们就直接进入catch，输出异常，而不会执行输出name的语句。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    String name=<span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">    <span class="type">int</span> num=Integer.parseInt(name);</span><br><span class="line">    System.out.println(name);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">    System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>throws</p>
<p>如果一个方法中的语句执行时可能生成某种异常，但不能确定怎么处理这种异常，则应显示地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;<span class="comment">//文件不存在异常</span></span><br><span class="line">    FileInputStream fis=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">&#125;<span class="comment">//让调用f1方法的调用者处理异常</span></span><br></pre></td></tr></table></figure>

<p>有以下两点值得注意</p>
<ul>
<li>throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类；</li>
<li>throws关键字后面也可以是异常列表，即可以抛出多个异常。</li>
</ul>
<p>遇到异常可以抛给上一级，或者使用try-catch-finally机制。值得注意的是，try-catch-finally机制和throws机制只能二选一，不能两个都用。直到遇到<code>JVM</code>（最顶级）它处理异常的机制为输出异常信息，退出程序。</p>
<p>如果一段代码既没有用try-catch-finally机制也没有用throws机制，那么系统默认使用throws.</p>
</li>
</ul>
<h2 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h2><ul>
<li><p>对于编译异常，程序中必须处理，比如try-catch或throws</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException&#123;</span><br><span class="line">        FileInputStream fis=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;<span class="comment">//这么写报错，必须得在后面也加上throws FileNotFoundException或try-catch</span></span><br><span class="line">        m1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>m1抛出了一个编译异常，当m2调用时，m2不能不处理从m1接受的编译异常，因此需要使用try-catch或throws.</p>
</li>
<li><p>对于运行时异常，程序中如果没有处理，默认就是throws方式处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> <span class="keyword">throws</span> ArithmeticException&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;</span><br><span class="line">        m1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依旧是上面的例子，在这里ArithmeticException是运行时异常，程序默认以throws方式处理，故不会报错</p>
</li>
<li><p>子类重写父类的方法时，对抛出异常的规定：子类重写的方法，所抛出异常类型要么和父类抛出的异常一致，要么为父类抛出异常的子类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span><span class="keyword">throws</span> RuntimeException&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span><span class="keyword">throws</span> ArithmeticException&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>​	上面的<code>RuntimeException</code>为<code>ArithmeticException</code>的父类，因此可以重写</p>
<ul>
<li>在throws过程中，如果有方法try-catch，就相当于处理异常，就不需要使用throws了</li>
</ul>
<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>当程序中出现了某些错误时，但该错误信息并没有在<code>Throwable</code>中表述处理，这个时候可以自己设计异常累，用于表示该错误信息。</p>
<p>我们直接看例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> age=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(age&lt;<span class="number">18</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AgeException</span>(<span class="string">&quot;年龄需要大于18岁&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;年龄正确&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeException</span><span class="params">(String age)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们要实现一个判断年龄的功能，如果年龄小于十八岁，那么抛出一个异常。这里我们写了一个类<code>AgeException</code>，它是继承了<code>RuntimeException</code>的一个类。我们在自定义异常的时候，如果继承Exception，属于编译异常；如果继承<code>RuntimeException</code>，属于运行异常。当需要抛出异常的时候，构造器将字符串传给父类，以此实现相关功能。</p>
<p>一般情况下，我们自定义异常是继承<code>RuntimeException</code>，把自定义异常写成运行时异常的好处是可以使用默认的处理机制。</p>
<h2 id="throws和throw的区别"><a href="#throws和throw的区别" class="headerlink" title="throws和throw的区别"></a>throws和throw的区别</h2><table>
<thead>
<tr>
<th></th>
<th align="center">意义</th>
<th align="center">位置</th>
<th align="center">后面跟的东西</th>
</tr>
</thead>
<tbody><tr>
<td>throws</td>
<td align="center">异常处理的一种方式</td>
<td align="center">方法声明处</td>
<td align="center">异常类型</td>
</tr>
<tr>
<td>throw</td>
<td align="center">手动生成异常对象的关键字</td>
<td align="center">方法体中</td>
<td align="center">异常对象</td>
</tr>
</tbody></table>
<h1 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h1><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><p>针对八种基本数据类型相应的引用类型</p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">包装类</th>
</tr>
</thead>
<tbody><tr>
<td align="center">boolean</td>
<td align="center">Boolean</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">Character</td>
</tr>
<tr>
<td align="center">byte</td>
<td align="center">Byte</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">Short</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">Integer</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">Long</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">Float</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">Double</td>
</tr>
</tbody></table>
<h3 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h3><p>首先先解释一下什么是装箱和拆箱。装箱就是基本类型转换为包装类型，而拆箱就是包装类型转换为基本类型。</p>
<ul>
<li><p>jdk5以前是手动装箱和拆箱</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">100</span>;</span><br><span class="line"><span class="comment">//手动装箱第一种写法</span></span><br><span class="line">Integer integer=<span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line"><span class="comment">//第二种写法</span></span><br><span class="line">Integer integer1=Integer.valueOf(i);</span><br><span class="line"><span class="comment">//手动拆箱</span></span><br><span class="line"><span class="type">int</span> i1=integer.intValue();</span><br></pre></td></tr></table></figure>
</li>
<li><p>jdk5以后是自动装箱和拆箱</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自动装箱</span></span><br><span class="line">Integer integer2=i;</span><br><span class="line"><span class="comment">//自动拆箱</span></span><br><span class="line"><span class="type">int</span> i2=integer2;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>其实，自动装箱底层仍然使用的是手动装箱的方法，系统自动帮你写好了。</p>
<p>其他包装类的用法类似，这里就不过多赘述了。</p>
<p><strong>小练习</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj=<span class="literal">true</span>?<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>):<span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">2.0</span>);</span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure>

<p>分析如上语句的输出结果。</p>
<p>三目运算符，前面为真，返回冒号前面的值，因此<code>Object obj=new Integer(1)</code>，按理说应该输出1，但是这里的三目运算符要当成一个整体，因此要输出1.0</p>
<h3 id="包装类方法"><a href="#包装类方法" class="headerlink" title="包装类方法"></a>包装类方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Integer和String互相转换</span></span><br><span class="line"><span class="comment">//包装类--&gt;String类型</span></span><br><span class="line">Integer i=<span class="number">10</span>;</span><br><span class="line"><span class="comment">//方式1</span></span><br><span class="line">String s1=i.toString();</span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line">String s2=String.valueOf(i);</span><br><span class="line"><span class="comment">//方式3</span></span><br><span class="line">String s3=i+<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="comment">//String类型--&gt;包装类</span></span><br><span class="line">String s4=<span class="string">&quot;12&quot;</span>;</span><br><span class="line"><span class="comment">//方式1</span></span><br><span class="line">Integer j=<span class="keyword">new</span> <span class="title class_">Integer</span>(s4);</span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line">Integer j2=Integer.valueOf(s4);</span><br></pre></td></tr></table></figure>

<h2 id="Integer类"><a href="#Integer类" class="headerlink" title="Integer类"></a>Integer类</h2><p>我们来看几个样例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i1=<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">Integer i2=<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">System.out.println(i1==i2);</span><br></pre></td></tr></table></figure>

<p>显而易见，即便是两个值均为1，但他们是新创建的两个对象，因此不等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer j1=<span class="number">1</span>;</span><br><span class="line">Integer j2=<span class="number">1</span>;</span><br><span class="line">System.out.println(j1==j2);</span><br></pre></td></tr></table></figure>

<p>这里很容易就想到<code>j1=j2</code>，但真的是这样吗？上面我们提到了自动装箱的实质：<code>Integer.valueOf</code>.我们来看一下这个方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里有一个限制条件，传入的参数必须在一个范围之内，否则会创建一个对象。因此这里判断<code>j1</code>和<code>j2</code>是否相等就看传入参数的范围。<code>IntegerCache.low</code>和<code>IntegerCache.high</code>到底表示什么呢？我们再看它的源码可知，最小值为-127，最大值为128.因此，如果传入的参数小于等于128且大于等于-127，都不会创建新的对象。故这里<code>j1</code>和<code>j2</code>相等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer k1=<span class="number">128</span>;</span><br><span class="line">Integer k2=<span class="number">128</span>;</span><br><span class="line">System.out.println(k1==k2);</span><br></pre></td></tr></table></figure>

<p>所以这一段代码就不相等了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i1=<span class="number">128</span>;</span><br><span class="line"><span class="type">int</span> i2=<span class="number">128</span>;</span><br><span class="line">System.out.println(i1==i2);</span><br></pre></td></tr></table></figure>

<p>只要有基本数据类型，直接判断值是否相等，因此上面输出true.</p>
<h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li><p>字符串的字符使用Unicode字符编码，一个字符无论是字母还是汉字都占两个字节。</p>
</li>
<li><p>String类实现了接口<code>Serializable</code>（String可以串行化：可以在网络传输）、接口<code>Comparable</code>（String对象可以比较大小）</p>
</li>
<li><p>String是final类，不能被其他类继承</p>
</li>
<li><p>我们在翻String的源码时，会有这样一句话<code>private final char value[];</code></p>
<p>表示用于存放字符串内容，此外这个value被final修饰，故不可以修改。这里的修改不是指字符串的内容不能修改，而是value不能指向新的地址。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">char</span> v[] =&#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>&#125;;</span><br><span class="line">v[<span class="number">0</span>]=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">char</span> v2[]=&#123;<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>&#125;;</span><br><span class="line">v=v2;<span class="comment">//error</span></span><br></pre></td></tr></table></figure>

<p>v字符数组我们用final修饰，我们将他指向v2直接报错。</p>
</li>
</ul>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul>
<li><p>直接赋值<code>String s=&quot;xxx&quot;;</code></p>
<p>先从常量池查看是否有<code>&quot;xxx&quot;</code>数据空间，如果有，直接指向；如果没有，则重新创建，然后指向。s最终指向的是常量池的空间地址。</p>
</li>
<li><p>调用构造器<code>String s=new String(&quot;xxx&quot;);</code></p>
<p>先在堆中创建空间，里面维护了<code>value</code>的属性，指向常量池的<code>&quot;xxx&quot;</code>空间。如果常量池没有<code>&quot;xxx&quot;</code>，重新创建，如果有，直接通过<code>value</code>指向，最终指向的是堆中的空间地址。</p>
</li>
</ul>
<h3 id="内存-1"><a href="#内存-1" class="headerlink" title="内存"></a>内存</h3><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.equals</span></span><br><span class="line">    String str1=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    String str2=<span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    String str3=<span class="string">&quot;Hellohello&quot;</span>;</span><br><span class="line">    String str4=<span class="string">&quot;helloHellohello&quot;</span>;</span><br><span class="line">    System.out.println(str1.equals(str2));<span class="comment">//判断内容是否相等，区分大小写</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.equalsIgnoreCase</span></span><br><span class="line">    <span class="keyword">if</span>(str1.equalsIgnoreCase(str2))&#123;<span class="comment">//判断内容是否相等，忽略大小写</span></span><br><span class="line">        System.out.println(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> System.out.println(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.indexOf</span></span><br><span class="line">    System.out.println(str3.indexOf(str1));<span class="comment">//获取字符在字符串第一次出现的索引，从0开始，找不到返回-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.lastIndexOf</span></span><br><span class="line">    System.out.println(str4.lastIndexOf(str1));<span class="comment">//获取字符在字符串最后一次出现的索引</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5.substring</span></span><br><span class="line">    System.out.println(str3.substring(<span class="number">5</span>));<span class="comment">//从给定索引开始截取后面所有的内容</span></span><br><span class="line">    System.out.println(str3.substring(<span class="number">0</span>,<span class="number">5</span>));<span class="comment">//从0开始截取，截取到索引为5的字符串，不包括5</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//6.toUpperCase</span></span><br><span class="line">    System.out.println(str1.toUpperCase());<span class="comment">//将字符串转换成大写</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//7.toLowerCase</span></span><br><span class="line">    System.out.println(str1.toUpperCase().toLowerCase());<span class="comment">//将字符串转换成小写</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//8.concat</span></span><br><span class="line">    System.out.println(str1.concat(str2));<span class="comment">//拼接</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//9.replace</span></span><br><span class="line">    str3=str3.replace(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>);<span class="comment">//将原来字符串里的hello替换成world</span></span><br><span class="line">    System.out.println(str3);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//10.split</span></span><br><span class="line">    String poem=<span class="string">&quot;锄禾日当午,汗滴禾下土,谁知盘中餐,粒粒皆辛苦&quot;</span>;</span><br><span class="line">    String[]split=poem.split(<span class="string">&quot;,&quot;</span>);<span class="comment">//以逗号分割字符串，并保存到字符串数组里</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;split.length;i++)&#123;</span><br><span class="line">        System.out.println(split[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//11.toCharArray</span></span><br><span class="line">    <span class="type">char</span>[]c=str1.toCharArray();<span class="comment">//将String转换为字符数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;c.length;i++)&#123;</span><br><span class="line">        System.out.println(c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//12.format</span></span><br><span class="line">    String name=<span class="string">&quot;jack&quot;</span>;</span><br><span class="line">    <span class="type">int</span> age=<span class="number">18</span>;</span><br><span class="line">    String info=String.format(<span class="string">&quot;我的名字是%s，年龄是%d&quot;</span>,name,age);</span><br><span class="line">    System.out.println(info);</span><br><span class="line">    <span class="comment">//%s,%d等叫做占位符，占位符有后面的变量替换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p><code>StringBuffer</code>代表可变的字符序列，可以对字符串内容进行增删，很多方法与String是相同的，但<code>StringBuffer</code>是可变长度的。</p>
<ul>
<li><code>StringBuffer</code>的直接父类是<code>AbstractStringBuffer</code></li>
<li><code>StringBuffer</code>实现了<code>Serializable</code>，即它的对象可以串行化</li>
<li>在<code>AbstractStringBuffer</code>中，有属性char[ ]value，但它不是final修饰的。该value数组存放字符串内容，存放在堆中</li>
<li><code>StringBuffer</code>是一个final类，不能被继承</li>
</ul>
<p>String和<code>StringBuffer</code>的对比</p>
<ul>
<li>String保存的是字符串常量，里面的值不能更改，每次String类的更新实际上就是更改地址，效率较低。</li>
<li><code>StringBuffer</code>保存的是字符串变量，里面的值可以更改，每次<code>StringBuffer</code>的更新实际上可以更新内容，不用每次更新地址，效率较高。</li>
</ul>
<h4 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h4><p>1、构造一个不带字符的字符串缓冲区，其初始容量为16个字符。我们进到StringBuffer的源码可以看到它的构造器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer stringBuffer=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">StringBuffer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>故容量（capacity）为16.</p>
<p>2、构造一个不带字符，但具有指定初始容量的字符串缓冲区，即对char[]的大小进行指定。同样我们可以看它的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer stringBuffer1=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">StringBuffer</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、构造一个字符串缓冲区，并将其内容初始化为指定的字符串内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer stringBuffer2=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;tom&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">StringBuffer</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h4><ul>
<li><p>String–&gt;StringBuffer</p>
<p>方式1：使用构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">StringBuffer b1=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(s);</span><br></pre></td></tr></table></figure>

<p>方式2：使用append方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer b1=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">b1.append(s);</span><br></pre></td></tr></table></figure>
</li>
<li><p>StringBuffer–&gt;String</p>
<p>方式1：使用<code>toString</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s2=b1.toString();</span><br></pre></td></tr></table></figure>

<p>方式2：使用构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s3=<span class="keyword">new</span> <span class="title class_">String</span>(b1);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//追加</span></span><br><span class="line">    StringBuffer s=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    s.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    s.append(<span class="string">&quot;1&quot;</span>).append(<span class="string">&quot;2&quot;</span>).append(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    System.out.println(s);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    s.delete(<span class="number">4</span>,<span class="number">5</span>);<span class="comment">//删除大于4但小于等于5的字符</span></span><br><span class="line">    System.out.println(s);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//替换</span></span><br><span class="line">    s.replace(<span class="number">4</span>,<span class="number">5</span>,<span class="string">&quot;%&quot;</span>);<span class="comment">//将大于4但小于等于5的字符替换为指定字符</span></span><br><span class="line">    System.out.println(s);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//查找</span></span><br><span class="line">    <span class="type">int</span> index= s.indexOf(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    System.out.println(index);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//插入</span></span><br><span class="line">    s.insert(<span class="number">5</span>,<span class="string">&quot;***&quot;</span>);</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a><code>StringBuilder</code></h3><p><code>StringBuilder</code>和<code>StringBuffer</code>均代表可变的字符序列，方法是一样的。只不过<code>StringBuilder</code>用于单线程，<code>StringBuffer</code>用于多线程。</p>
<ul>
<li><p><code>StringBuilder</code>实现了<code>Serializable</code>，即它的对象可以串行化</p>
</li>
<li><p><code>StringBuilder</code>是一个final类，不能被继承</p>
</li>
<li><p><code>StringBuilder</code>对象字符序列仍然是存放在其父类<code>AbstractStringBuffer</code>，的char[]value中，因此也存放在堆中</p>
</li>
<li><p><code>StringBuilder</code>所有方法没有做互斥的处理，因此在单线程的情况下使用</p>
</li>
</ul>
<h3 id="String、StringBuffer和StringBuilder的比较"><a href="#String、StringBuffer和StringBuilder的比较" class="headerlink" title="String、StringBuffer和StringBuilder的比较"></a>String、StringBuffer和StringBuilder的比较</h3><ul>
<li><code>String</code>：不可变字符序列，效率低，但复用率高</li>
<li><code>StringBuffer</code>：可变字符序列，效率高，线程安全</li>
<li><code>StringBuilder</code>：可变字符序列，效率最高，线程不安全</li>
</ul>
<p>如果字符串存在大量的修改操作，并且在单线程的情况下，使用<code>StringBuilder</code>；如果在多线程的情况下，使用<code>StringBuffer</code>；如果字符串很少修改，被多个对象引用，使用<code>String</code>.</p>
<h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//abs 绝对值</span></span><br><span class="line"><span class="type">int</span> abs=Math.abs(-<span class="number">1</span>);</span><br><span class="line"><span class="comment">//pow 求幂</span></span><br><span class="line"><span class="type">double</span> pow=Math.pow(<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line"><span class="comment">//ceil 向上取整</span></span><br><span class="line"><span class="type">double</span> ceil=Math.ceil(<span class="number">3.0001</span>);</span><br><span class="line"><span class="comment">//floor 向下取整</span></span><br><span class="line"><span class="type">double</span> floor=Math.floor(<span class="number">3.9999</span>);</span><br><span class="line"><span class="comment">//round 四舍五入</span></span><br><span class="line"><span class="type">long</span> round=Math.round(<span class="number">5.55</span>);</span><br><span class="line"><span class="comment">//sqrt 开方</span></span><br><span class="line"><span class="type">double</span> sqrt=Math.sqrt(<span class="number">4</span>);</span><br><span class="line"><span class="comment">//random 求随机数</span></span><br><span class="line"><span class="comment">//返回大于等于0 但 小于1 之间的一个随机小数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    System.out.println(Math.random());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h2><p>Arrays里面包含了一系列静态方法，用于管理或操作数组。下面具体介绍几种方法。</p>
<p>下面所有代码一定不能忘记导入<code>java.util.Arrays</code></p>
<ul>
<li><p><code>toString</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer[] a =&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">System.out.println(Arrays.toString(a));</span><br></pre></td></tr></table></figure>

<p>遍历数组</p>
</li>
<li><p>sort</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(a);</span><br></pre></td></tr></table></figure>

<p>sort排序后，会直接影响到实参。</p>
<p>此外也可以通过一个接口Comparator实现定制排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(a, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1-o2;</span><br><span class="line">        <span class="comment">//源码最终执行到binarysort</span></span><br><span class="line">        <span class="comment">//o1-o2还是o2-o1直接决定的返回的正负性，从而决定了排序顺序，即从大到小还是从小到大</span></span><br><span class="line">    &#125;<span class="comment">//实现Comparator接口的匿名内部类</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>根据指定比较器产生的顺序对指定的对象数组进行排序，这里的Comparator就是比较器。下面来看一个具体的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">bubble_sort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Integer a[]=&#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        bubbleSort(a, <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">                <span class="type">int</span> i1=(Integer)o1;</span><br><span class="line">                <span class="type">int</span> i2=(Integer)o2;</span><br><span class="line">                <span class="keyword">return</span> i2-i1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);<span class="comment">//小括号不能漏</span></span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(Integer a[],Comparator c)</span>&#123;</span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;a.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(c.compare(a[i],a[j])&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> temp=a[j];</span><br><span class="line">                    a[j]=a[i];</span><br><span class="line">                    a[i]=temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先看到bubblesort里面的结构非常熟悉，这就是我们之前提到的匿名内部类，尤以结尾的小括号瞩目。而冒泡排序的关键在于两趟循环指向值的大小比较，因此我们在这里“设限”，将比较器塞进去，即compare方法，这样我们才能根据上面指定的正负性来合理调用if判断。</p>
</li>
<li><p>binarySearch</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/10/%E6%9F%B3%E6%9A%97%E8%8A%B1%E6%98%8E%E5%8F%88%E4%B8%80%E6%9D%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XuSpring">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="伊甸园">
      <meta itemprop="description" content="放码过来">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 伊甸园">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/01/10/%E6%9F%B3%E6%9A%97%E8%8A%B1%E6%98%8E%E5%8F%88%E4%B8%80%E6%9D%91/" class="post-title-link" itemprop="url">柳暗花明又一村</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-01-10 18:55:58" itemprop="dateCreated datePublished" datetime="2024-01-10T18:55:58+08:00">2024-01-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-01-23 22:20:02" itemprop="dateModified" datetime="2024-01-23T22:20:02+08:00">2024-01-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="我的第一篇博客"><a href="#我的第一篇博客" class="headerlink" title="我的第一篇博客"></a>我的第一篇博客</h1><h2 id="为什么我要写博客"><a href="#为什么我要写博客" class="headerlink" title="为什么我要写博客"></a>为什么我要写博客</h2><p>    自幼以来，我常常能在网页上浏览到其他大佬所制作的精美网站。小时候的我，谈不上在意这些枯燥的网页知识，但精美绝伦的网页总能给我带来极佳的视觉享受。到了高中、大学，接触的博客越来越多，一开始是百度贴吧之类的帖子， 后来逐渐用上了知乎，CSDN等网站获取知识，现在几乎每天都要浏览别人写的博客，算法啊，解题步骤之类的。</p>
<p>    最近，我迷上了别人写的博客，心中的欲望油然而生，我也幻想着什么时候能够自己建立一个既美观又实用的博客。于是我开始搜寻浏览方法，最后我盯上了知乎上的一篇“从零开始建立博客”，二话没说我就开始了自己的步伐。</p>
<p>    还有一个原因就是提升自己。面试的时候，有自己的一个博客是加分项，同时如果能让别人浏览的化更是一种满足感，同时还能增强语言表达技巧以及代码能力，何尝不是一种双全的办法啊！</p>
<h2 id="博客的大致方向"><a href="#博客的大致方向" class="headerlink" title="博客的大致方向"></a>博客的大致方向</h2><p>    一篇好的文章需要思路，博客亦是如此。我没有在互联网上发表过自己的见解，上次写作还是在高考（难以启齿QAQ）所以刚写难免有一些纰漏，敬请谅解。</p>
<p>    <strong>我的大致思路是</strong></p>
<ul>
<li>第一个阶段</li>
</ul>
<p>  </p>
<p>       分享大学生活，以及自己的学习经历、目标；</p>
<ul>
<li>第二个阶段</li>
</ul>
<p>       逐步尝试写题解、知识点、注意事项等小宗；</p>
<ul>
<li><p>第三个阶段</p>
<p>尝试写框架、项目，以及未来的走向。</p>
</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>    道阻且长，行稳致远。</p>
<p>    写博客是个漫长的过程，众所周知，不能一口吃成大胖子。语言知识的积累，往往在数年的键盘敲击声中慢慢形成。星辰大海，总有适合自己的一片天地。</p>
<h1 id="大一上的小结"><a href="#大一上的小结" class="headerlink" title="大一上的小结"></a>大一上的小结</h1><p>    安带（简称安徽大学）——一所末流211。很荣幸我来到了安带，并进行了为期半年的学习，带给我的感受就五个字，平庸却充实。</p>
<h2 id="学习成果"><a href="#学习成果" class="headerlink" title="学习成果"></a>学习成果</h2><p>    大一要学的科目不多，也就高数英语之类的外加几门水课。想摆的话非常轻松，以各位能来安大的实力，跨个及格线不成问题。但问题就在于，究竟哪种方式适合大一的生活？</p>
<p>    要不就成天死学，学它个头破血流，可是科目就这么多吧，卷到底也只是课本上的知识点罢了，我觉得不太适合我。要不就纯摆，考前突击，按道理来说是可以这么做，但问题又来了，你不学总得找事情来消遣吧，玩游戏、胡吃海喝……耗费了巨额的钱财不说，反倒长胖了几斤，这明显是不划算的。我记得我们计导老师这么说的，游戏就相当于数据的重写与覆盖，这么一听貌似是这样的。后来我索性就把游戏删掉了，那能干点啥呢，我这不就过来写博客了嘛。</p>
<p>    话虽如此，但一到考试就废。就拿期中考试来说，各科只有八十出头，相较于全班普遍九十加的人来说，我就像是将军里的矮子。你问我干啥去了，我也讲不出来，也许是态度不端正吧，总之还有很多要改的地方。</p>
<p>    还有就是学了几门语言，C就不用说了，学校基础的教材，其次是C++，目前正在学Java。站在岸边的我早已窥见对岸遍地的Java……算法呢我也略知一二，这种逻辑性极强的东西一时半会是不可能学成的，只有不断积累，反复练习才有可能达到熟练运用的效果。</p>
<h2 id="项目成果"><a href="#项目成果" class="headerlink" title="项目成果"></a>项目成果</h2><p>    一个大一刚来半年的新生能做出什么像样的东西呢？确实是这样的，目前这个阶段只能混一混经验。十月份左右我就抱着试一试的心态，加了一个项目组长的联系方式，简单的交谈过后，竟成功的进去了新徽商创业大赛的小组。幸运的是，那个小组当时成功过了一试，我去的时候就开始决赛了。当时的项目原本是外卖柜，后来经过老师指点改为了心愿柜。外卖柜出发点是好的， 可是实现难度较高，后期不仅赚不到钱，可能还贴很多钱进去，得不偿失，因此我们索性换个方向。当然，这些询问老师之类的活明显不是我干的，我一个花钱都不明不白的人还想着怎么赚钱，实在可笑！但到后面又出现了大问题，就是项目探索过程中，突然发现没有与别人竞争的创新点，经过一直讨论后面就改为了梦想柜。其实过程中一直有个隐性的痛点，就是项目实现的形式：实体还是app。实体虽然便捷，但初期成本高，还需要很多人力去维护，并且需要考虑到地点天气等其他因素；app虽然没有线下环境因素的影响，但开发、维护、服务器等后续成本过高。可是，比赛毕竟是比赛，在不脱离现实的情况下，可以大胆设想，无需做出来成品。因此，我们最后将方向定为app。我是负责app设计这块的，这种美工其实与我这专业毫不相干，但由于我之前有一定的美工基础，干起来也能够轻车熟路、不忙不乱。最后到了验收的阶段，老师安排每个小组上去答辩，我们组在倒二，不至于一上来就踩坑。看了别的组的精彩答辩后，顷刻间我觉得我们组的项目黯然失色。有的项目甚至签约了公司，我怀疑它们把互联网+的项目搬来参加这种比赛，属于大炮打蚊子。最后我们组名副其实的参与奖，不论如何，每个组的创意都很惊艳，（未完待续）</p>
<p>    只要有了第一次，第二次、第三次接踵而至。到了年末，由于大创的申报时间即将结束，许多人都在为自己的大创项目招聘组员，但我心里清楚，能在网上挂着的大多都是些不好的项目，而且大多数组长对于成员的要求都是大二及以上。可是我能混到一点经验算不错了，于是我就大胆将自己的特长挂在了墙上。不出所料，果然有很多人加上了我的联系方式，逐一排查后，我选择了一个“互联网对安徽地摊经济的影响调查”的项目。由于这个大创项目并不是那么的复杂，一进去就开始着手写申报书了，每个人负责一个模块，效率挺高，花了一两天时间大概就完成了申报书的撰写。然后大一上就匆匆结束了。</p>
<p>    总的来说，我并不为自己混了几个项目而满足，换做别人照样能干得很好。</p>
<h1 id="大一下的小目标"><a href="#大一下的小目标" class="headerlink" title="大一下的小目标"></a>大一下的小目标</h1><h2 id="学习，还是学习"><a href="#学习，还是学习" class="headerlink" title="学习，还是学习"></a>学习，还是学习</h2><p>    由于大一上体验了半年的摆子生活，顿感乏力，迫切需要寻找一个新的方式唤起我的“良知”。大一下的专业课明显比上学期的难度要大了，我觉得摆正自己的态度才是最重要的。之前总是眼高手低，自以为那些专业课知识非常简单，一看就懂，但到了实际运用的时候一塌糊涂。此外，在学好专业课的基础上，还需要涉猎课外的知识，包括正在学的java以及后面打算了解的js等，争取在大一暑假期间找到合适的外包小项目（痴人说梦~）</p>
<h2 id="出片"><a href="#出片" class="headerlink" title="出片"></a>出片</h2><p>    有了相机怎么能让它在角落积灰呢，多多扫街才算得上是物尽其用。今年打算去一趟巢湖拍日落，这必然是一次绝妙的体验；再去看看海，以前去海边只知道怼着大海一顿瞎拍，根本不懂得构图一说法，这也算的上是弥补过去的遗憾了。还有星空，去年我拿着我的手机熬了几次夜都没能拍出自己较为满意的星空图，这次我将拿上相机再战，希望会有好一点的收获，英仙座等着我！ 我还想爬上合肥的高楼，淋漓尽致地用上一次超广角，暴露出合肥的每一条马路，每一座高楼和被阻挡的太阳。</p>
<p>    提升摄影技能也是关键，包括构图法，后期的P图。相信在这一年的学习加实战，我能够产出一些比较优质的作品。</p>
<h2 id="锻炼"><a href="#锻炼" class="headerlink" title="锻炼"></a>锻炼</h2><p>    第一学期那憋屈的体测成绩我都不忍直视，我发誓新的一年我要加强锻炼，在耐力、爆发力等各个方面都需要做出改变，我可不想一直成为别人口中的“细狗”哇！</p>
<h2 id="完善博客"><a href="#完善博客" class="headerlink" title="完善博客"></a>完善博客</h2><p>    目前的博客在很多方面都比较欠缺，包括美化、功能以及质量，我尽量坚持每天码出一点文章的习惯，此外对之前写过的“技术”博客进行复习查错。</p>
<p>    </p>
<pre><code>                               
</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/default-index/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/default-index/">1</a><span class="page-number current">2</span>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-java"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">XuSpring</span>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
